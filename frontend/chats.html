<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>InstaPing | Chats</title>
  <link rel="icon" type="image/png" href="asset/logo.jpeg">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000000;
      color: #FFFFFF;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      flex-direction: column;
      background: #000000;
      border-bottom: 1px solid #1F1F1F;
      z-index: 100;
      padding-bottom: 12px;
    }
    .search-bar {
      display: flex;
      align-items: center;
      padding: 12px 16px 8px;
      gap: 12px;
    }
    .search-input {
      flex: 1;
      background: #1F1F1F;
      border: none;
      border-radius: 24px;
      padding: 12px 16px;
      color: #FFFFFF;
      font-size: 16px;
      outline: none;
    }
    .search-input::placeholder { color: #8E8E8E; }
    .header-icons { 
      position: absolute;
      right: 16px;
      top: 16px;
      display: flex; 
      gap: 20px; 
    }
    .header-icon { width: 24px; height: 24px; cursor: pointer; fill: #FFFFFF; }
    .chat-list { 
      flex: 1; 
      overflow-y: auto; 
      padding: 140px 24px 80px;
      position: relative;
    }
    .chat-item {
      display: flex;
      align-items: center;
      padding: 12px 0;
      cursor: pointer;
      transition: background 0.2s ease;
    }
    .chat-item:hover, .chat-item:focus { 
      background: #1F1F1F; 
      outline: none;
    }
    .profile-photo {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      overflow: hidden;
      margin-right: 16px;
      background: #2A2A2A;
      position: relative;
      flex-shrink: 0;
    }
    .profile-photo img { width: 100%; height: 100%; object-fit: cover; }
    .online-dot {
      position: absolute;
      bottom: 4px;
      right: 4px;
      width: 12px;
      height: 12px;
      background: #00FF00;
      border-radius: 50%;
      border: 2px solid #000000;
      box-shadow: 0 0 8px #00FF0080;
    }
    .online-dot.busy { background: #FFFF00; }
    .online-dot.away { background: #FF0000; }
    .chat-details { flex: 1; overflow: hidden; }
    .chat-name { font-size: 16px; font-weight: 600; margin-bottom: 4px; }
    .last-message {
      font-size: 14px;
      color: #A0A0A0;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .last-message-icon {
      width: 16px;
      height: 16px;
      flex-shrink: 0;
      fill: #A0A0A0;
    }
    .chat-meta { display: flex; flex-direction: column; align-items: flex-end; gap: 8px; }
    .timestamp { font-size: 12px; color: #8E8E8E; }
    .unread-count {
      background: #1E90FF;
      color: #FFFFFF;
      font-size: 12px;
      font-weight: 600;
      min-width: 18px;
      height: 18px;
      border-radius: 9px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 6px;
    }
    /* Updated Empty State - centered and hidden during loading */
    .empty-state {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px 24px;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.4s ease;
    }
    .empty-state.show {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }
    .empty-icon { width: 120px; height: 120px; margin-bottom: 32px; opacity: 0.3; }
    .empty-title { font-size: 20px; margin-bottom: 12px; }
    .empty-subtitle { font-size: 16px; color: #8E8E8E; line-height: 1.5; }
    .bottom-nav {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      height: 64px;
      background: #1F1F1F;
      border-top: 1px solid #2A2A2A;
      z-index: 100;
    }
    .nav-item {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: #8E8E8E;
      cursor: pointer;
    }
    .nav-item.active { color: #FFFFFF; }
    .nav-icon svg { width: 24px; height: 24px; margin-bottom: 4px; fill: currentColor; }
    .fab {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 64px;
      height: 64px;
      background: #FFFFFF;
      color: #000000;
      border-radius: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      cursor: pointer;
      z-index: 101;
      border: none;
    }
    .fab svg { width: 32px; height: 32px; fill: currentColor; }
    #toast {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(31, 31, 31, 0.95);
      color: #FFFFFF;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 13px;
      font-weight: 500;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, transform 0.3s ease;
      z-index: 200;
      max-width: 90%;
      text-align: center;
      backdrop-filter: blur(8px);
    }
    #toast.show {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(-8px);
    }
    .logo-small { width: 40px; height: 40px; }
    .logo-small img { width: 100%; height: 100%; object-fit: contain; }

    /* Shimmer Loading */
    .shimmer-wrapper {
      position: absolute;
      inset: 0;
      padding: 0 24px;
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.4s ease;
      z-index: 10;
    }
    .shimmer-wrapper.hidden { opacity: 0; visibility: hidden; }
    .shimmer-item {
      display: flex;
      align-items: center;
      padding: 12px 0;
      animation: pulse 2s infinite ease-in-out;
    }
    .shimmer-photo { width: 56px; height: 56px; border-radius: 50%; background: #2A2A2A; margin-right: 16px; }
    .shimmer-details { flex: 1; }
    .shimmer-name { height: 16px; width: 50%; background: #2A2A2A; border-radius: 8px; margin-bottom: 8px; }
    .shimmer-msg { height: 14px; width: 70%; background: #2A2A2A; border-radius: 8px; }
    .shimmer-meta { display: flex; flex-direction: column; align-items: flex-end; gap: 12px; }
    .shimmer-time { height: 12px; width: 40px; background: #2A2A2A; border-radius: 8px; }

    /* Typing Indicator */
    .typing-indicator {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 12px;
      color: #1E90FF;
      font-style: italic;
    }
    .typing-dot {
      width: 4px;
      height: 4px;
      background: #1E90FF;
      border-radius: 50%;
      animation: typingPulse 1.5s infinite ease-in-out;
    }
    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }

    @keyframes pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    @keyframes typingPulse {
      0%, 100% { opacity: 0.4; transform: translateY(0); }
      50% { opacity: 1; transform: translateY(-4px); }
    }

    /* Clear Search Button */
    .clear-search-btn {
      margin-top: 20px;
      padding: 10px 20px;
      background: #FFF;
      color: #000;
      border: none;
      border-radius: 20px;
      cursor: pointer;
      font-weight: 500;
    }
    .clear-search-btn:hover {
      background: #F0F0F0;
    }

    /* Loading overlay */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease;
    }
    .loading-overlay.show {
      opacity: 1;
      visibility: visible;
    }
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid #1F1F1F;
      border-top-color: #1E90FF;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }
    .loading-text {
      color: #FFFFFF;
      font-size: 14px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <header>
    <div class="search-bar">
      <div class="logo-small">
        <img src="asset/logo.png" alt="Coded Logo">
      </div>
      <input type="text" class="search-input" id="search-input" placeholder="Search chats..." aria-label="Search chats">
    </div>
    <div class="header-icons"></div>
  </header>

  <div class="chat-list" id="chat-list">
    <!-- Shimmer skeleton -->
    <div class="shimmer-wrapper" id="shimmer">
      <div class="shimmer-item">
        <div class="shimmer-photo"></div>
        <div class="shimmer-details">
          <div class="shimmer-name"></div>
          <div class="shimmer-msg"></div>
        </div>
        <div class="shimmer-meta">
          <div class="shimmer-time"></div>
        </div>
      </div>
      <div class="shimmer-item">
        <div class="shimmer-photo"></div>
        <div class="shimmer-details">
          <div class="shimmer-name"></div>
          <div class="shimmer-msg"></div>
        </div>
        <div class="shimmer-meta">
          <div class="shimmer-time"></div>
        </div>
      </div>
      <div class="shimmer-item">
        <div class="shimmer-photo"></div>
        <div class="shimmer-details">
          <div class="shimmer-name"></div>
          <div class="shimmer-msg"></div>
        </div>
        <div class="shimmer-meta">
          <div class="shimmer-time"></div>
        </div>
      </div>
      <div class="shimmer-item">
        <div class="shimmer-photo"></div>
        <div class="shimmer-details">
          <div class="shimmer-name"></div>
          <div class="shimmer-msg"></div>
        </div>
        <div class="shimmer-meta">
          <div class="shimmer-time"></div>
        </div>
      </div>
    </div>

    <!-- Empty State -->
    <div class="empty-state" id="empty-state">
      <div class="empty-icon">üí¨</div>
      <div class="empty-title">No chats yet</div>
      <div class="empty-subtitle">Start a conversation to connect with others</div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loading-overlay">
    <div class="loading-spinner"></div>
    <div class="loading-text" id="loading-text">Loading...</div>
  </div>

  <!-- Bottom Nav -->
  <div class="bottom-nav">
    <div class="nav-item" id="nav-live">
      <div class="nav-icon">
        <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/></svg>
      </div>
      <div>Live</div>
    </div>
    <div class="nav-item" id="nav-favorites">
      <div class="nav-icon">
        <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
      </div>
      <div>Favorites</div>
    </div>
    <div class="nav-item"></div>
    <div class="nav-item active" id="nav-chats">
      <div class="nav-icon">
        <svg viewBox="0 0 24 24"><path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"/></svg>
      </div>
      <div>Chats</div>
    </div>
    <div class="nav-item" id="nav-profile">
      <div class="nav-icon">
        <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
      </div>
      <div>Profile</div>
    </div>

    <button class="fab" id="fab-post" aria-label="Post Request">
      <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
    </button>
  </div>

  <div id="toast"></div>

<script>
   const fallbackImage = 'https://upload.wikimedia.org/wikipedia/commons/8/89/Portrait_Placeholder.png';
const API_BASE_URL = 'https://www.instaping.org/api';
let currentUserId = null;
let wsManager = null;
let allChats = [];
let customEventListeners = [];
let loadedCount = 0;
const visibleChats = 20;
let typingTimeouts = new Map();

// ==================== UTILITY FUNCTIONS ====================
function showToast(message, duration = 2000) {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.classList.add('show');
    clearTimeout(toast.hideTimeout);
    toast.hideTimeout = setTimeout(() => toast.classList.remove('show'), duration);
}

function showLoading(message = 'Loading...') {
    const overlay = document.getElementById('loading-overlay');
    const text = document.getElementById('loading-text');
    text.textContent = message;
    overlay.classList.add('show');
}

function hideLoading() {
    const overlay = document.getElementById('loading-overlay');
    overlay.classList.remove('show');
}

function playNotificationSound() {
    try {
        const audio = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA==');
        audio.volume = 0.3;
        audio.play().catch(e => console.log('Audio play failed:', e));
    } catch (e) {
        console.log('Audio not supported');
    }
}

function parseJwt(token) {
    try {
        const base64Url = token.split('.')[1];
        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
        const payload = JSON.parse(jsonPayload);
        return payload.userId || payload.sub || payload.id || null;
    } catch (e) {
        console.error('Failed to parse JWT:', e);
        return null;
    }
}

function formatTimestamp(unix) {
    if (!unix) return '';
    const date = new Date(unix * 1000);
    const now = new Date();
    const diffMs = now - date;
    const diffSec = Math.floor(diffMs / 1000);

    if (diffSec < 60) return 'Just now';
    if (diffSec < 3600) return Math.floor(diffSec / 60) + 'm';
    if (diffSec < 86400) return Math.floor(diffSec / 3600) + 'h';

    return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
}

function addCustomEventListener(element, event, handler) {
    element.addEventListener(event, handler);
    customEventListeners.push({ element, event, handler });
}

function cleanupEventListeners() {
    customEventListeners.forEach(({ element, event, handler }) => {
        element.removeEventListener(event, handler);
    });
    customEventListeners = [];
}

// ==================== WEBSOCKET MANAGER WITH IMPROVED POLLING FALLBACK ====================
class ChatWebSocketManager {
    constructor() {
        this.socket = null;
        this.reconnectInterval = 3000;
        this.maxReconnectAttempts = 5;
        this.reconnectAttempts = 0;
        this.isConnected = false;
        this.shouldReconnect = true;
        this.messageListeners = [];
        this.heartbeatInterval = 30000;
        this.heartbeatTimer = null;
        this.useWebSockets = true;
        this.pollingInterval = null;
        this.chatRefreshInterval = null;
        
        // Improved polling properties
        this.lastChatUpdateTime = 0;
        this.optimisticUpdates = new Map();
        this.pollingBackoff = 5000;
        this.maxPollingBackoff = 60000;
        this.pollingFailures = 0;
        this.maxPollingFailures = 3;
        this.connectionStats = {
            mode: 'websocket',
            uptime: 0,
            modeSwitches: 0,
            totalPolls: 0,
            successfulPolls: 0,
            failedPolls: 0
        };
    }

    connect() {
        if (this.socket?.readyState === WebSocket.OPEN) {
            return;
        }

        const token = localStorage.getItem('token');
        if (!token) {
            console.warn('No token found, WebSocket connection deferred');
            return;
        }

        // Auto-detect if we should use WebSocket or polling
        const isLocalhost = window.location.hostname === 'localhost' || 
                           window.location.hostname === '127.0.0.1';
        
        // For production (Render), try WebSocket first but fall back to polling
        let wsUrl;
        
        if (isLocalhost) {
            wsUrl = `ws://localhost:8080/ws?token=${encodeURIComponent(token)}`;
            console.log('üîå Connecting to Local WebSocket:', wsUrl);
        } else {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host.replace(/^www\./, '');
            wsUrl = `${protocol}//${host}/ws?token=${encodeURIComponent(token)}`;
            console.log('üåê Connecting to Production WebSocket:', wsUrl);
        }
        
        try {
            this.socket = new WebSocket(wsUrl);
            
            this.socket.onopen = () => {
                console.log('‚úÖ WebSocket connected');
                this.isConnected = true;
                this.reconnectAttempts = 0;
                this.useWebSockets = true;
                this.connectionStats.mode = 'websocket';
                
                // Start heartbeat
                this.startHeartbeat();
                
                // Subscribe to chat updates
                this.send({
                    type: 'subscribe',
                    channel: 'chat_updates'
                });
                
                this.send({
                    type: 'subscribe',
                    channel: 'message_updates'
                });
                
                showToast('üí¨ Live chat updates active');
                
                // Clear any polling intervals since WebSocket is working
                this.stopPolling();
                this.stopChatRefresh();
                
                // Reset polling stats
                this.pollingFailures = 0;
                this.pollingBackoff = 5000;
            };

            this.socket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log('üì® WebSocket message:', data);
                    this.handleMessage(data);
                    
                    // Notify all listeners
                    this.messageListeners.forEach(listener => listener(data));
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                }
            };

            this.socket.onclose = (event) => {
                console.log('‚ùå WebSocket disconnected');
                this.isConnected = false;
                
                if (this.heartbeatTimer) {
                    clearInterval(this.heartbeatTimer);
                    this.heartbeatTimer = null;
                }
                
                if (this.shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    console.log(`üîÑ Reconnecting attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts}...`);
                    
                    // Show toast only on first disconnect
                    if (this.reconnectAttempts === 1) {
                        showToast('üîå Reconnecting...');
                    }
                    
                    setTimeout(() => this.connect(), this.reconnectInterval);
                } else if (this.shouldReconnect) {
                    console.error('Max reconnection attempts reached, switching to polling mode');
                    this.switchToPollingMode();
                }
            };

            this.socket.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

        } catch (error) {
            console.error('Failed to create WebSocket:', error);
            
            if (this.shouldReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {
                this.reconnectAttempts++;
                setTimeout(() => this.connect(), this.reconnectInterval);
            } else if (this.shouldReconnect) {
                this.switchToPollingMode();
            }
        }
    }

    switchToPollingMode() {
        console.log('üîÑ Switching to HTTP polling mode');
        this.useWebSockets = false;
        this.isConnected = false;
        this.connectionStats.mode = 'polling';
        this.connectionStats.modeSwitches++;
        
        // Silent switch - don't show toast unless it's been a while
        if (this.reconnectAttempts >= 3) {
            showToast('üì° Using polling mode (slower updates)');
        }
        
        // Start polling for updates
        this.startPolling();
        
        // Start periodic refresh of chats (but more subtly)
        this.startChatRefresh();
        
        // Log analytics if available
        if (typeof gtag !== 'undefined') {
            gtag('event', 'connection_mode_switch', {
                'event_category': 'network',
                'event_label': 'websocket_to_polling'
            });
        }
    }

    startPolling() {
        // Poll for new messages with current backoff interval
        if (!this.pollingInterval) {
            console.log(`üì° Starting polling with ${this.pollingBackoff}ms interval`);
            this.pollingInterval = setInterval(async () => {
                if (!this.useWebSockets) {
                    await this.pollForNewMessages();
                }
            }, this.pollingBackoff);
        }
    }

    stopPolling() {
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
            this.pollingInterval = null;
        }
    }

    async pollForNewMessages() {
        this.connectionStats.totalPolls++;
        const startTime = Date.now();
        
        try {
            const token = localStorage.getItem('token');
            if (!token) return;

            // Get only chats that have been updated since last check
            const response = await fetch(`${API_BASE_URL}/chats?since=${this.lastChatUpdateTime}&limit=50`, {
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.ok) {
                this.connectionStats.successfulPolls++;
                const updatedChats = await response.json();
                
                if (updatedChats.length > 0) {
                    console.log('üîÑ Polling found', updatedChats.length, 'updated chats');
                    
                    // Update last update time
                    this.lastChatUpdateTime = Math.floor(Date.now() / 1000);
                    
                    // Process each updated chat individually
                    updatedChats.forEach(chat => {
                        this.processUpdatedChat(chat);
                    });
                    
                    // Reset failures on successful poll
                    this.pollingFailures = 0;
                    this.pollingBackoff = 5000; // Reset to initial interval
                    
                    // Restart polling with normal interval
                    this.stopPolling();
                    this.startPolling();
                }
                
                // Record ping time
                const pingTime = Date.now() - startTime;
                console.log(`üì° Poll completed in ${pingTime}ms`);
                
            } else {
                throw new Error(`HTTP ${response.status}`);
            }
            
        } catch (error) {
            console.error('Polling error:', error);
            this.connectionStats.failedPolls++;
            this.pollingFailures++;
            
            // Exponential backoff
            if (this.pollingFailures <= this.maxPollingFailures) {
                this.pollingBackoff = Math.min(
                    this.pollingBackoff * 2,
                    this.maxPollingBackoff
                );
                
                console.log(`‚ö†Ô∏è Polling backoff to ${this.pollingBackoff}ms (failure ${this.pollingFailures}/${this.maxPollingFailures})`);
                
                // Restart polling with new interval
                this.stopPolling();
                this.startPolling();
            } else {
                console.error('Max polling failures reached, stopping polling');
                this.stopPolling();
                showToast('‚ö†Ô∏è Connection issues - refresh page to retry');
            }
        }
    }

    processUpdatedChat(updatedChat) {
        // Check if we already have this chat
        const existingChatIndex = allChats.findIndex(c => c.id === updatedChat.id);
        
        if (existingChatIndex !== -1) {
            // Chat exists - update it in place
            const existingChat = allChats[existingChatIndex];
            
            // Check if there's actually new content
            const hasNewMessage = updatedChat.lastMessageAt && 
                                 (!existingChat.lastMessageAt || 
                                  updatedChat.lastMessageAt > existingChat.lastMessageAt);
            
            const hasUnreadChange = updatedChat.unreadCount !== existingChat.unreadCount;
            const hasStatusChange = updatedChat.partner?.status !== existingChat.partner?.status;
            
            if (hasNewMessage || hasUnreadChange || hasStatusChange) {
                console.log('üì± Updating chat in place:', updatedChat.id);
                
                // Update the chat in our array
                allChats[existingChatIndex] = updatedChat;
                
                // Update the UI without full refresh
                this.updateChatInUI(updatedChat);
                
                // Play notification sound if there's a new message not from current user
                if (hasNewMessage && updatedChat.lastMessage && 
                    updatedChat.lastMessage.senderId !== currentUserId) {
                    playNotificationSound();
                    
                    // Show subtle notification only if user isn't currently viewing chats
                    if (!document.hasFocus()) {
                        showToast(`üí¨ New message from ${updatedChat.partner?.name || 'Someone'}`);
                    }
                }
            }
        } else {
            // New chat - add it to the list
            console.log('‚ûï Adding new chat from polling:', updatedChat.id);
            allChats.unshift(updatedChat);
            this.addNewChatToUI(updatedChat);
        }
    }

    updateChatInUI(chat) {
        const chatListEl = document.getElementById('chat-list');
        const chatItem = chatListEl.querySelector(`[data-chat-id="${chat.id}"]`);
        
        if (chatItem) {
            // Get partner info
            const partner = chat.partner || { name: 'Unknown', avatar: fallbackImage, status: 'offline' };
            const isOnline = partner.status === 'available';
            const isBusy = partner.status === 'busy';
            const isAway = partner.status === 'away';

            // Prepare last message preview
            let lastPreview = 'No messages yet';
            let previewIcon = '';

            if (chat.lastMessage) {
                const msg = chat.lastMessage;

                if (typeof msg === 'object' && msg.type === 'image') {
                    lastPreview = 'Photo';
                    previewIcon = '<svg class="last-message-icon" viewBox="0 0 24 24" style="display:inline-block;width:16px;height:16px;margin-right:4px;vertical-align:middle"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>';
                } else if (typeof msg === 'object' && msg.type === 'text' && msg.content) {
                    lastPreview = msg.content;
                } else if (typeof msg === 'string') {
                    if (msg.trim() === '') {
                        lastPreview = 'No messages yet';
                    } else if (msg.includes('res.cloudinary.com') || msg.includes('image') || msg.includes('photo')) {
                        lastPreview = 'Photo';
                        previewIcon = '<svg class="last-message-icon" viewBox="0 0 24 24" style="display:inline-block;width:16px;height:16px;margin-right:4px;vertical-align:middle"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>';
                    } else {
                        lastPreview = msg.trim();
                    }
                }
            }

            // Truncate long messages
            if (lastPreview.length > 30) {
                lastPreview = lastPreview.substring(0, 30) + '...';
            }

            const unreadCount = chat.unreadCount || 0;
            const unreadBadge = unreadCount > 0 
                ? `<div class="unread-count">${unreadCount > 99 ? '99+' : unreadCount}</div>` 
                : '';

            // Update the chat item content
            const chatDetails = chatItem.querySelector('.chat-details');
            const chatMeta = chatItem.querySelector('.chat-meta');
            const profilePhoto = chatItem.querySelector('.profile-photo');
            
            if (chatDetails) {
                const chatName = chatDetails.querySelector('.chat-name');
                const lastMessage = chatDetails.querySelector('.last-message');
                
                if (chatName) chatName.textContent = partner.name || 'Unknown';
                if (lastMessage) {
                    lastMessage.innerHTML = `${previewIcon}${lastPreview}`;
                }
            }
            
            if (chatMeta) {
                chatMeta.innerHTML = `
                    <div class="timestamp">${formatTimestamp(chat.lastMessageAt)}</div>
                    ${unreadBadge}
                `;
            }
            
            // Update online status
            const onlineDot = profilePhoto.querySelector('.online-dot');
            if (onlineDot) {
                if (isOnline || isBusy || isAway) {
                    onlineDot.style.display = 'block';
                    onlineDot.classList.remove('busy', 'away');
                    if (isBusy) onlineDot.classList.add('busy');
                    if (isAway) onlineDot.classList.add('away');
                } else {
                    onlineDot.style.display = 'none';
                }
            }
            
            // Move to top if there's a new message (within last minute)
            if (chat.lastMessageAt && chat.lastMessageAt > (Date.now() / 1000 - 60)) {
                chatListEl.insertBefore(chatItem, chatListEl.firstChild);
            }
            
            // Add subtle animation for the update
            chatItem.classList.add('updated');
            setTimeout(() => chatItem.classList.remove('updated'), 1000);
        }
    }

    addNewChatToUI(chat) {
        const chatListEl = document.getElementById('chat-list');
        const emptyStateEl = document.getElementById('empty-state');
        
        // Hide empty state if showing
        if (emptyStateEl.classList.contains('show')) {
            emptyStateEl.classList.remove('show');
        }
        
        // Check if chat already exists in UI
        if (chatListEl.querySelector(`[data-chat-id="${chat.id}"]`)) {
            return;
        }
        
        // Get partner info
        const partner = chat.partner || { name: 'Unknown', avatar: fallbackImage, status: 'offline' };
        const isOnline = partner.status === 'available';
        const isBusy = partner.status === 'busy';
        const isAway = partner.status === 'away';

        // Prepare last message preview
        let lastPreview = 'No messages yet';
        let previewIcon = '';

        if (chat.lastMessage) {
            const msg = chat.lastMessage;
            if (typeof msg === 'object' && msg.type === 'image') {
                lastPreview = 'Photo';
                previewIcon = '<svg class="last-message-icon" viewBox="0 0 24 24" style="display:inline-block;width:16px;height:16px;margin-right:4px;vertical-align:middle"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>';
            } else if (typeof msg === 'object' && msg.type === 'text' && msg.content) {
                lastPreview = msg.content;
            }
        }

        const unreadCount = chat.unreadCount || 0;
        const unreadBadge = unreadCount > 0 
            ? `<div class="unread-count">${unreadCount > 99 ? '99+' : unreadCount}</div>` 
            : '';

        const item = document.createElement('div');
        item.className = 'chat-item';
        item.dataset.chatId = chat.id;
        item.dataset.userId = partner.id || '';
        item.setAttribute('role', 'button');
        item.setAttribute('tabindex', '0');
        item.setAttribute('aria-label', `Chat with ${partner.name || 'Unknown'}. ${unreadCount > 0 ? `${unreadCount} unread messages` : 'No unread messages'}`);
        item.innerHTML = `
            <div class="profile-photo">
                <img src="${partner.avatar || fallbackImage}" alt="${partner.name}" onerror="this.src='${fallbackImage}'">
                ${isOnline || isBusy || isAway ? 
                    `<div class="online-dot ${isBusy ? 'busy' : ''} ${isAway ? 'away' : ''}"></div>` : ''}
            </div>
            <div class="chat-details">
                <div class="chat-name">${partner.name || 'Unknown'}</div>
                <div class="last-message">
                    ${previewIcon}
                    ${lastPreview.length > 30 ? lastPreview.substring(0, 30) + '...' : lastPreview}
                </div>
            </div>
            <div class="chat-meta">
                <div class="timestamp">${formatTimestamp(chat.lastMessageAt)}</div>
                ${unreadBadge}
            </div>
        `;
        
        // Add click handler
        addCustomEventListener(item, 'click', () => {
            window.location.href = `chat.html?id=${chat.id}`;
        });
        
        // Add keyboard support
        addCustomEventListener(item, 'keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                window.location.href = `chat.html?id=${chat.id}`;
            }
        });
        
        // Insert at top with fade-in animation
        item.style.opacity = '0';
        item.style.transform = 'translateY(-10px)';
        
        if (chatListEl.firstChild) {
            chatListEl.insertBefore(item, chatListEl.firstChild);
        } else {
            chatListEl.appendChild(item);
        }
        
        // Animate in
        setTimeout(() => {
            item.style.transition = 'all 0.3s ease';
            item.style.opacity = '1';
            item.style.transform = 'translateY(0)';
        }, 10);
    }

    startChatRefresh() {
        // Refresh entire chat list every 2 minutes in polling mode (less frequent)
        if (!this.chatRefreshInterval) {
            this.chatRefreshInterval = setInterval(() => {
                if (!this.useWebSockets) {
                    console.log('üîÑ Silent background chat refresh in polling mode');
                    this.refreshChatsSilently();
                }
            }, 120000); // 2 minutes
        }
    }

    stopChatRefresh() {
        if (this.chatRefreshInterval) {
            clearInterval(this.chatRefreshInterval);
            this.chatRefreshInterval = null;
        }
    }

    async refreshChatsSilently() {
        try {
            const token = localStorage.getItem('token');
            if (!token) return;

            const response = await fetch(`${API_BASE_URL}/chats`, {
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.ok) {
                const newChats = await response.json();
                
                // Update allChats array
                allChats = Array.isArray(newChats) ? newChats : [];
                
                // Update last update time
                this.lastChatUpdateTime = Math.floor(Date.now() / 1000);
                
                console.log('üì± Silent chat refresh completed');
            }
        } catch (error) {
            console.error('Silent refresh error:', error);
        }
    }

    startHeartbeat() {
        this.heartbeatTimer = setInterval(() => {
            if (this.socket?.readyState === WebSocket.OPEN) {
                this.send({ type: 'ping' });
            }
        }, this.heartbeatInterval);
    }

    stopHeartbeat() {
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
    }

    send(data) {
        if (this.socket?.readyState === WebSocket.OPEN) {
            this.socket.send(JSON.stringify(data));
            return true;
        } else if (this.useWebSockets) {
            console.warn('WebSocket not ready, retrying...');
            setTimeout(() => this.send(data), 1000);
            return false;
        } else {
            console.log('üì° Polling mode active - skipping WebSocket send');
            return false;
        }
    }

    handleMessage(data) {
        const { type, payload } = data;
        
        switch (type) {
            case 'new_message':
                this.handleNewMessage(payload);
                break;
                
            case 'message_read':
                this.handleMessageRead(payload);
                break;
                
            case 'typing_start':
                this.handleTypingStart(payload);
                break;
                
            case 'typing_end':
                this.handleTypingEnd(payload);
                break;
                
            case 'user_status_update':
                this.handleUserStatusUpdate(payload);
                break;
                
            case 'chat_created':
                this.handleChatCreated(payload);
                break;
                
            case 'pong':
                console.log('‚ù§Ô∏è WebSocket heartbeat received');
                break;
                
            default:
                console.log('Unknown WebSocket message type:', type);
        }
    }

    handleNewMessage(message) {
        console.log('üÜï New message received:', message);
        
        // Play notification sound if message is not from current user
        if (message.senderId !== currentUserId) {
            playNotificationSound();
            showToast(`üí¨ New message from ${message.sender?.name || 'Someone'}`);
        }
        
        // Update the chat list
        this.updateChatFromMessage(message);
    }

    updateChatFromMessage(message) {
        // Find the chat in our array
        const chatIndex = allChats.findIndex(c => c.id === message.chatId);
        
        if (chatIndex !== -1) {
            const chat = allChats[chatIndex];
            
            // Update chat with new message
            chat.lastMessage = message;
            chat.lastMessageAt = message.createdAt || Math.floor(Date.now() / 1000);
            
            // Increment unread count if message is not from current user
            if (message.senderId !== currentUserId) {
                chat.unreadCount = (chat.unreadCount || 0) + 1;
            } else {
                // If message is from current user, clear unread count
                chat.unreadCount = 0;
            }
            
            // Move to top of array
            allChats.splice(chatIndex, 1);
            allChats.unshift(chat);
            
            // Update UI
            this.updateChatInUI(chat);
        } else {
            // Chat not found, reload chats
            console.log('‚ùå Chat not found, reloading...');
            loadChats();
        }
    }

    handleMessageRead(payload) {
        console.log('üìñ Message read update:', payload);
        
        // Find the chat and update unread count
        const chatIndex = allChats.findIndex(c => c.id === payload.chatId);
        if (chatIndex !== -1) {
            const chat = allChats[chatIndex];
            
            // Decrement unread count (simple approach)
            if (chat.unreadCount > 0) {
                chat.unreadCount = Math.max(0, chat.unreadCount - payload.messageIds.length);
            }
            
            // Update UI
            this.updateChatInUI(chat);
        }
    }

    handleTypingStart(payload) {
        console.log('‚úçÔ∏è User typing:', payload);
        showTypingIndicator(payload.chatId, payload.userId);
        
        if (typingTimeouts.has(payload.chatId)) {
            clearTimeout(typingTimeouts.get(payload.chatId));
        }
        typingTimeouts.set(payload.chatId, setTimeout(() => {
            hideTypingIndicator(payload.chatId);
        }, 3000));
    }

    handleTypingEnd(payload) {
        console.log('‚èπÔ∏è User stopped typing:', payload);
        hideTypingIndicator(payload.chatId);
        
        if (typingTimeouts.has(payload.chatId)) {
            clearTimeout(typingTimeouts.get(payload.chatId));
            typingTimeouts.delete(payload.chatId);
        }
    }

    handleUserStatusUpdate(payload) {
        console.log('üìä User status updated:', payload);
        
        // Update all chats with this user
        allChats.forEach(chat => {
            if (chat.partner?.id === payload.userId) {
                chat.partner.status = payload.status;
                this.updateChatInUI(chat);
            }
        });
    }

    handleChatCreated(payload) {
        console.log('üí¨ New chat created:', payload);
        this.addNewChatToUI(payload);
        allChats.unshift(payload);
    }

    disconnect() {
        this.shouldReconnect = false;
        this.stopPolling();
        this.stopChatRefresh();
        this.stopHeartbeat();
        
        if (this.socket) {
            this.socket.close();
            this.socket = null;
        }
        
        this.isConnected = false;
        this.useWebSockets = true; // Reset for next connection attempt
    }

    sendTypingStart(chatId) {
        this.send({
            type: 'typing_start',
            payload: { chatId }
        });
    }

    sendTypingEnd(chatId) {
        this.send({
            type: 'typing_end', 
            payload: { chatId }
        });
    }

    sendMessageRead(chatId, messageIds) {
        this.send({
            type: 'message_read',
            payload: { chatId, messageIds }
        });
    }
    
    addMessageListener(listener) {
        this.messageListeners.push(listener);
    }
    
    removeMessageListener(listener) {
        const index = this.messageListeners.indexOf(listener);
        if (index > -1) {
            this.messageListeners.splice(index, 1);
        }
    }
    
    getConnectionStats() {
        return {
            ...this.connectionStats,
            pollingSuccessRate: this.connectionStats.totalPolls > 0 
                ? (this.connectionStats.successfulPolls / this.connectionStats.totalPolls * 100).toFixed(1)
                : 0,
            pollingBackoff: this.pollingBackoff,
            pollingFailures: this.pollingFailures
        };
    }
}

// ==================== UI UPDATE FUNCTIONS ====================
function showTypingIndicator(chatId, userId) {
    const chatItem = document.querySelector(`[data-chat-id="${chatId}"]`);
    if (chatItem) {
        const lastMessageEl = chatItem.querySelector('.last-message');
        if (lastMessageEl) {
            lastMessageEl.innerHTML = `
                <div class="typing-indicator">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <span>typing...</span>
                </div>
            `;
        }
    }
}

function hideTypingIndicator(chatId) {
    const chatItem = document.querySelector(`[data-chat-id="${chatId}"]`);
    if (chatItem) {
        // Find the chat in allChats to restore the last message
        const chat = allChats.find(c => c.id === chatId);
        if (chat && chat.lastMessage) {
            const lastMessageEl = chatItem.querySelector('.last-message');
            if (lastMessageEl) {
                let preview = chat.lastMessage.content || '';
                let previewIcon = '';
                
                if (chat.lastMessage.type === 'image') {
                    preview = 'Photo';
                    previewIcon = '<svg class="last-message-icon" viewBox="0 0 24 24" style="display:inline-block;width:16px;height:16px;margin-right:4px;vertical-align:middle"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>';
                }
                
                lastMessageEl.innerHTML = `
                    ${previewIcon}
                    ${preview.length > 30 ? preview.substring(0, 30) + '...' : preview}
                `;
            }
        }
    }
}

// ==================== CHAT RENDERING ====================
function renderChats(chats, append = false) {
    console.log('üé® Rendering chats:', chats.length, 'append:', append);
    
    const chatListEl = document.getElementById('chat-list');
    const emptyStateEl = document.getElementById('empty-state');

    if (!append) {
        loadedCount = 0;
        // Clear existing chats
        const existingChats = chatListEl.querySelectorAll('.chat-item');
        existingChats.forEach(chat => chat.remove());
    }

    if (chats.length === 0 && !append) {
        emptyStateEl.classList.add('show');
        emptyStateEl.querySelector('.empty-title').textContent = 'No chats yet';
        emptyStateEl.querySelector('.empty-subtitle').textContent = 'Start a conversation to connect with others';
        return;
    }

    if (!append) {
        emptyStateEl.classList.remove('show');
    }

    // Sort chats by lastMessageAt (newest first)
    const chatsToRender = [...chats].sort((a, b) => (b.lastMessageAt || 0) - (a.lastMessageAt || 0));
    const chatsToShow = chatsToRender.slice(loadedCount, loadedCount + visibleChats);

    chatsToShow.forEach((chat) => {
        const partner = chat.partner || { name: 'Unknown', avatar: fallbackImage, status: 'offline' };
        const isOnline = partner.status === 'available';
        const isBusy = partner.status === 'busy';
        const isAway = partner.status === 'away';

        let lastPreview = 'No messages yet';
        let previewIcon = '';

        if (chat.lastMessage) {
            const msg = chat.lastMessage;

            if (typeof msg === 'object' && msg.type === 'image') {
                lastPreview = 'Photo';
                previewIcon = '<svg class="last-message-icon" viewBox="0 0 24 24" style="display:inline-block;width:16px;height:16px;margin-right:4px;vertical-align:middle"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>';
            } else if (typeof msg === 'object' && msg.type === 'text' && msg.content) {
                lastPreview = msg.content;
            } else if (typeof msg === 'string') {
                if (msg.trim() === '') {
                    lastPreview = 'No messages yet';
                } else if (msg.includes('res.cloudinary.com') || msg.includes('image') || msg.includes('photo')) {
                    lastPreview = 'Photo';
                    previewIcon = '<svg class="last-message-icon" viewBox="0 0 24 24" style="display:inline-block;width:16px;height:16px;margin-right:4px;vertical-align:middle"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>';
                } else {
                    lastPreview = msg.trim();
                }
            }
        }

        // Truncate long messages
        if (lastPreview.length > 30) {
            lastPreview = lastPreview.substring(0, 30) + '...';
        }

        const unreadCount = chat.unreadCount || 0;
        const unreadBadge = unreadCount > 0 
            ? `<div class="unread-count">${unreadCount > 99 ? '99+' : unreadCount}</div>` 
            : '';

        const item = document.createElement('div');
        item.className = 'chat-item';
        item.dataset.chatId = chat.id;
        item.dataset.userId = partner.id || '';
        item.setAttribute('role', 'button');
        item.setAttribute('tabindex', '0');
        item.setAttribute('aria-label', `Chat with ${partner.name || 'Unknown'}. ${unreadCount > 0 ? `${unreadCount} unread messages` : 'No unread messages'}. Last message: ${lastPreview}`);
        item.innerHTML = `
            <div class="profile-photo">
                <img src="${partner.avatar || fallbackImage}" alt="${partner.name}" onerror="this.src='${fallbackImage}'">
                ${isOnline || isBusy || isAway ? 
                    `<div class="online-dot ${isBusy ? 'busy' : ''} ${isAway ? 'away' : ''}"></div>` : ''}
            </div>
            <div class="chat-details">
                <div class="chat-name">${partner.name || 'Unknown'}</div>
                <div class="last-message">
                    ${previewIcon}
                    ${lastPreview}
                </div>
            </div>
            <div class="chat-meta">
                <div class="timestamp">${formatTimestamp(chat.lastMessageAt)}</div>
                ${unreadBadge}
            </div>
        `;
        
        // Add click handler
        addCustomEventListener(item, 'click', () => {
            console.log('Opening chat:', chat.id);
            window.location.href = `chat.html?id=${chat.id}`;
        });
        
        // Add keyboard support
        addCustomEventListener(item, 'keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                window.location.href = `chat.html?id=${chat.id}`;
            }
        });
        
        chatListEl.appendChild(item);
    });
    
    loadedCount += chatsToShow.length;
    
    // Add infinite scroll listener if not already added
    if (!window.chatScrollHandler) {
        window.chatScrollHandler = () => {
            if (chatListEl.scrollTop + chatListEl.clientHeight >= chatListEl.scrollHeight - 100) {
                if (loadedCount < chats.length) {
                    renderChats(chats, true);
                }
            }
        };
        addCustomEventListener(chatListEl, 'scroll', window.chatScrollHandler);
    }
    
    console.log(`‚úÖ ${chatsToShow.length} chats rendered (total loaded: ${loadedCount}/${chats.length})`);
}

// ==================== MAIN LOADING FUNCTION ====================
async function loadChats() {
    const chatListEl = document.getElementById('chat-list');
    const emptyStateEl = document.getElementById('empty-state');
    const shimmerEl = document.getElementById('shimmer');

    // Get token from localStorage
    const token = localStorage.getItem('token');
    
    if (!token) {
        showToast('Please log in first.');
        setTimeout(() => window.location.href = 'login.html', 1500);
        return;
    }

    // Show shimmer, hide empty state
    shimmerEl.classList.remove('hidden');
    emptyStateEl.classList.remove('show');

    try {
        console.log('üì° Loading chats from API...');
        const res = await fetch(`${API_BASE_URL}/chats`, {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (!res.ok) {
            if (res.status === 401) {
                showToast('Session expired. Please log in again.');
                localStorage.removeItem('token');
                setTimeout(() => window.location.href = 'login.html', 1500);
                return;
            }
            throw new Error(`HTTP error! status: ${res.status}`);
        }
        
        const data = await res.json();
        allChats = Array.isArray(data) ? data : [];
        console.log(`‚úÖ ${allChats.length} chats loaded`);

        // Update lastChatUpdateTime in WebSocket manager
        if (wsManager) {
            wsManager.lastChatUpdateTime = Math.floor(Date.now() / 1000);
        }

        // Hide shimmer
        shimmerEl.classList.add('hidden');
        renderChats(allChats);
    } catch (err) {
        console.error('‚ùå Chats load error:', err);
        
        if (err.message.includes('Failed to fetch')) {
            showToast('Network error. Check your internet connection.');
        } else if (err.message.includes('401')) {
            showToast('Session expired. Please log in again.');
            localStorage.removeItem('token');
            setTimeout(() => window.location.href = 'login.html', 1500);
            return;
        } else {
            showToast('Failed to load chats');
        }
        
        shimmerEl.classList.add('hidden');
        emptyStateEl.classList.add('show');
        emptyStateEl.querySelector('.empty-title').textContent = 'Failed to load';
        emptyStateEl.querySelector('.empty-subtitle').innerHTML = `
            Check your connection and try again<br>
            <button class="clear-search-btn" onclick="location.reload()">Retry</button>
        `;
    }
}

// ==================== SEARCH FUNCTION ====================
function setupSearch() {
    const searchInput = document.getElementById('search-input');
    
    addCustomEventListener(searchInput, 'input', () => {
        const query = searchInput.value.toLowerCase().trim();

        if (query === '') {
            renderChats(allChats);
            return;
        }

        const filtered = allChats.filter(chat => {
            const partner = chat.partner || {};
            const name = (partner.name || '').toLowerCase();
            const lastMessage = chat.lastMessage?.content || '';
            const lastMessageStr = typeof lastMessage === 'string' ? lastMessage.toLowerCase() : '';
            const chatId = chat.id || '';
            
            return name.includes(query) || 
                   lastMessageStr.includes(query) ||
                   chatId.includes(query);
        });

        renderChats(filtered);

        if (filtered.length === 0) {
            const emptyStateEl = document.getElementById('empty-state');
            emptyStateEl.classList.add('show');
            emptyStateEl.querySelector('.empty-title').textContent = 'No results found';
            emptyStateEl.querySelector('.empty-subtitle').innerHTML = 
                `No chats match "${query}"<br>
                 <button class="clear-search-btn" onclick="document.getElementById('search-input').value='';loadChats()">
                     Clear Search
                 </button>`;
        }
    });
}

// ==================== KEYBOARD NAVIGATION ====================
function setupKeyboardNavigation() {
    addCustomEventListener(document, 'keydown', (e) => {
        const chatItems = document.querySelectorAll('.chat-item');
        const activeElement = document.activeElement;
        
        if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
            e.preventDefault();
            const currentIndex = Array.from(chatItems).indexOf(activeElement);
            let nextIndex;
            
            if (e.key === 'ArrowDown') {
                nextIndex = currentIndex < chatItems.length - 1 ? currentIndex + 1 : 0;
            } else {
                nextIndex = currentIndex > 0 ? currentIndex - 1 : chatItems.length - 1;
            }
            
            if (chatItems[nextIndex]) {
                chatItems[nextIndex].focus();
            }
        } else if ((e.key === 'Enter' || e.key === ' ') && activeElement.classList.contains('chat-item')) {
            e.preventDefault();
            activeElement.click();
        }
    });
}

// ==================== NAVIGATION SETUP ====================
function setupNavigation() {
    const navItems = {
        'nav-live': 'live-requests.html',
        'nav-favorites': 'favorites.html',
        'nav-chats': () => window.location.reload(),
        'nav-profile': 'my-profile.html',
        'fab-post': 'post.html'
    };

    Object.entries(navItems).forEach(([id, target]) => {
        const element = document.getElementById(id);
        if (element) {
            addCustomEventListener(element, 'click', () => {
                if (typeof target === 'function') {
                    target();
                } else {
                    window.location.href = target;
                }
            });
        }
    });
}

// ==================== INITIALIZATION ====================
(function() {
    console.log('üöÄ Initializing chats page...');
    
    const token = localStorage.getItem('token');
    if (!token) {
        showToast('Please log in first.');
        setTimeout(() => window.location.href = 'login.html', 1500);
        return;
    }

    currentUserId = parseJwt(token);
    if (!currentUserId) {
        showToast('Invalid session. Please log in again.');
        localStorage.removeItem('token');
        setTimeout(() => window.location.href = 'login.html', 1500);
        return;
    }

    console.log('üë§ Current user ID:', currentUserId);

    // Setup components
    setupSearch();
    setupKeyboardNavigation();
    setupNavigation();

    // Initialize WebSocket manager
    wsManager = new ChatWebSocketManager();

    // Load chats
    loadChats();
    
    // Start WebSocket connection
    setTimeout(() => {
        console.log('üîå Starting WebSocket connection...');
        wsManager.connect();
        
        // Add message listener
        wsManager.addMessageListener((data) => {
            console.log('üì® WebSocket listener received:', data.type);
        });
    }, 1000);

    // Auto-refresh every 60 seconds as backup
    setInterval(() => {
        if (!wsManager.isConnected && wsManager.useWebSockets) {
            console.log('üîÑ Auto-refreshing chats (WebSocket disconnected)');
            loadChats();
        }
    }, 60000);

    // Add manual refresh button handler
    const refreshBtn = document.querySelector('.refresh-btn');
    if (refreshBtn) {
        addCustomEventListener(refreshBtn, 'click', () => {
            console.log('Manual refresh triggered');
            loadChats();
        });
    }

    // Clean up on page unload
    addCustomEventListener(window, 'beforeunload', () => {
        cleanupEventListeners();
        if (wsManager) {
            wsManager.disconnect();
        }
    });

    console.log('‚úÖ Chats page initialization complete');
})();
</script>
</body>

</html>

