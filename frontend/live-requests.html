<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>InstaPing | Live Requests</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#000000">
  <link rel="icon" type="image/png" href="asset/logo.jpeg">
  <link rel="icon" type="image/jpeg" href="asset/logo.jpeg">
  <link rel="apple-touch-icon" href="/asset/logo.jpeg">

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000000; color: #FFFFFF; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; min-height: 100vh; display: flex; flex-direction: column; }

    /* Desktop/PC message overlay */
    .desktop-message {
      position: fixed;
      inset: 0;
      background: #000000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 24px;
      z-index: 1000;
    }
    .desktop-message .icon {
      width: 120px;
      height: 120px;
      margin-bottom: 32px;
      opacity: 0.6;
    }
    .desktop-message h1 {
      font-size: 28px;
      margin-bottom: 16px;
    }
    .desktop-message p {
      font-size: 18px;
      color: #CCCCCC;
      max-width: 600px;
      line-height: 1.5;
    }

    /* Default: hide the app and show message on large screens */
    .desktop-message { display: flex; }
    header, .feed, .bottom-nav, #toast { display: none; }

    /* Show app on real touch devices (phones & tablets) */
    @media (hover: none) or (pointer: coarse) {
      .desktop-message { display: none; }
      header, .feed, .bottom-nav, #toast { display: block; }
    }

    /* Force show app when viewport is small (DevTools mobile view or resized window on PC) */
    @media (max-width: 1023px) {
      .desktop-message { display: none; }
      header, .feed, .bottom-nav, #toast { display: block; }
    }

    /* Override for bottom-nav to keep flex layout */
    .bottom-nav { display: flex; }

    header { position: fixed; top: 0; left: 0; right: 0; display: flex; justify-content: space-between; align-items: center; padding: 16px 24px; background: #000000; border-bottom: 1px solid #2A2A2A; z-index: 100; }
    .logo-small { width: 40px; height: 40px; }
    .logo-small img { width: 100%; height: 100%; object-fit: contain; }
    .status-indicator { padding: 8px 16px; background: #1F1F1F; border: 1px solid #2A2A2A; border-radius: 20px; font-size: 14px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 8px; }
    .status-indicator svg { width: 12px; height: 12px; }
    .status-available svg { fill: #00FF00; }
    .status-busy svg { fill: #FFFF00; }
    .status-offline svg { fill: #FF0000; }
    .feed { flex: 1; overflow-y: auto; padding: 16px 24px 80px; padding-top: 80px; position: relative; }
    .request-card { background: #1F1F1F; border-radius: 16px; padding: 20px; margin-bottom: 20px; display: flex; flex-direction: column; }
    .card-header { display: flex; align-items: center; margin-bottom: 12px; cursor: pointer; }
    .profile-photo { width: 64px; height: 64px; border-radius: 50%; overflow: hidden; margin-right: 16px; background: #2A2A2A; }
    .profile-photo img { width: 100%; height: 100%; object-fit: cover; }
    .user-info { flex: 1; }
    .name-age { font-size: 18px; font-weight: 600; }
    .distance { font-size: 14px; color: #8E8E8E; }
    .category { font-size: 14px; color: #FFFFFF; background: #2A2A2A; padding: 4px 12px; border-radius: 16px; align-self: flex-start; margin-bottom: 8px; }
    .request-text { font-size: 16px; margin-bottom: 12px; line-height: 1.4; }
    .card-footer { display: flex; justify-content: space-between; align-items: center; }
    .time-rating { font-size: 14px; color: #8E8E8E; display: flex; align-items: center; gap: 8px; }
    .time-rating svg { width: 16px; height: 16px; fill: #FFD700; }
    .actions { display: flex; gap: 12px; position: relative; }
    .action-btn { width: 48px; height: 48px; border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; background: transparent; }
    .action-btn svg { width: 24px; height: 24px; fill: #FFFFFF; transition: fill 0.4s ease, transform 0.4s ease; }
    .action-btn.favorite svg { fill: #FFFFFF; }
    .action-btn.favorite.favorited svg { fill: #FF0000; }
    .action-btn.favorite.animate svg { animation: heartPulse 0.6s ease; }
    @keyframes heartPulse { 0% { transform: scale(1); } 20% { transform: scale(1.4); } 40% { transform: scale(1.1); } 60% { transform: scale(1.4); } 100% { transform: scale(1); } }
    .bottom-nav { position: fixed; bottom: 0; left: 0; right: 0; height: 64px; background: #1F1F1F; border-top: 1px solid #2A2A2A; z-index: 100; }
    .nav-item { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 12px; color: #8E8E8E; cursor: pointer; }
    .nav-item.active { color: #FFFFFF; }
    .nav-icon svg { width: 24px; height: 24px; margin-bottom: 4px; fill: currentColor; }
    .fab { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); width: 64px; height: 64px; background: #FFFFFF; color: #000000; border-radius: 32px; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(0,0,0,0.5); cursor: pointer; z-index: 101; }
    .fab svg { width: 32px; height: 32px; fill: currentColor; }
    .no-requests { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #8E8E8E; font-size: 18px; width: 100%; padding: 0 24px; }
    .no-requests-icon { width: 96px; height: 96px; margin: 0 auto 24px; opacity: 0.4; }
    .no-requests h3 { font-size: 20px; margin-bottom: 12px; }
    .no-requests p { font-size: 16px; line-height: 1.5; }
    @keyframes confettiFall { 0% { transform: translateY(0) rotate(0deg); opacity: 1; } 100% { transform: translateY(80px) rotate(720deg); opacity: 0; } }
    .confetti-piece { position: absolute; width: 6px; height: 12px; pointer-events: none; animation: confettiFall 1s ease-out forwards; z-index: 10; }
    #toast { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); background: rgba(31, 31, 31, 0.95); color: #FFFFFF; padding: 8px 16px; border-radius: 20px; font-size: 13px; font-weight: 500; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4); opacity: 0; visibility: hidden; transition: opacity 0.3s ease, transform 0.3s ease; z-index: 200; max-width: 90%; text-align: center; backdrop-filter: blur(8px); }
    #toast.show { opacity: 1; visibility: visible; transform: translateX(-50%) translateY(-8px); }

    /* === ENHANCED SHIMMER LOADING === */
    .shimmer-wrapper {
      position: absolute;
      inset: 0;
      padding: 16px 24px;
      pointer-events: none;
      opacity: 1;
      transition: opacity 0.3s ease;
      z-index: 10;
    }
    
    .shimmer-wrapper.hidden {
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .shimmer-card {
      background: #1a1a1a;
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
      border: 1px solid #2A2A2A;
    }
    
    /* Shimmer effect */
    .shimmer-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -150%;
      width: 150%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.05) 20%,
        rgba(255, 255, 255, 0.1) 50%,
        rgba(255, 255, 255, 0.05) 80%,
        transparent 100%
      );
      animation: shimmer 1.5s infinite linear;
    }
    
    .shimmer-header {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
      position: relative;
      z-index: 1;
    }
    
    .shimmer-photo {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: #2A2A2A;
      margin-right: 16px;
      position: relative;
      overflow: hidden;
    }
    
    .shimmer-photo::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.08) 50%,
        transparent 100%
      );
      animation: shimmer 2s infinite linear;
      animation-delay: 0.3s;
    }
    
    .shimmer-lines {
      flex: 1;
      position: relative;
      z-index: 1;
    }
    
    .shimmer-line {
      height: 18px;
      background: #2A2A2A;
      border-radius: 8px;
      margin-bottom: 8px;
      position: relative;
      overflow: hidden;
    }
    
    .shimmer-line::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.08) 50%,
        transparent 100%
      );
      animation: shimmer 2s infinite linear;
    }
    
    .shimmer-line.short {
      width: 60%;
    }
    
    .shimmer-line:nth-child(2)::after {
      animation-delay: 0.2s;
    }
    
    .shimmer-category {
      height: 24px;
      width: 100px;
      background: #2A2A2A;
      border-radius: 16px;
      margin-bottom: 12px;
      position: relative;
      overflow: hidden;
      z-index: 1;
    }
    
    .shimmer-category::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.08) 50%,
        transparent 100%
      );
      animation: shimmer 2.5s infinite linear;
      animation-delay: 0.4s;
    }
    
    .shimmer-text {
      height: 16px;
      background: #2A2A2A;
      border-radius: 8px;
      margin-bottom: 8px;
      position: relative;
      overflow: hidden;
      z-index: 1;
    }
    
    .shimmer-text::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.08) 50%,
        transparent 100%
      );
      animation: shimmer 2s infinite linear;
    }
    
    .shimmer-text.long {
      width: 100%;
    }
    
    .shimmer-text.medium {
      width: 80%;
    }
    
    .shimmer-text:nth-child(2)::after {
      animation-delay: 0.1s;
    }
    
    .shimmer-text:nth-child(3)::after {
      animation-delay: 0.2s;
    }
    
    .shimmer-text:nth-child(4)::after {
      animation-delay: 0.3s;
    }
    
    .shimmer-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 12px;
      position: relative;
      z-index: 1;
    }
    
    .shimmer-time {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .shimmer-time-icon {
      width: 16px;
      height: 16px;
      background: #2A2A2A;
      border-radius: 4px;
      position: relative;
      overflow: hidden;
    }
    
    .shimmer-time-icon::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.08) 50%,
        transparent 100%
      );
      animation: shimmer 2s infinite linear;
      animation-delay: 0.5s;
    }
    
    .shimmer-time-text {
      width: 80px;
      height: 14px;
      background: #2A2A2A;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
    }
    
    .shimmer-time-text::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.08) 50%,
        transparent 100%
      );
      animation: shimmer 2s infinite linear;
      animation-delay: 0.6s;
    }
    
    .shimmer-actions {
      display: flex;
      gap: 12px;
    }
    
    .shimmer-btn {
      width: 48px;
      height: 48px;
      background: #2A2A2A;
      border-radius: 50%;
      position: relative;
      overflow: hidden;
    }
    
    .shimmer-btn::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.08) 50%,
        transparent 100%
      );
      animation: shimmer 2s infinite linear;
    }
    
    .shimmer-btn:nth-child(2)::after {
      animation-delay: 0.2s;
    }
    
    .shimmer-btn:nth-child(3)::after {
      animation-delay: 0.4s;
    }
    
    @keyframes shimmer {
      0% {
        left: -100%;
      }
      100% {
        left: 200%;
      }
    }
    
    /* Stagger animation for cards */
    .shimmer-card:nth-child(1)::before {
      animation-delay: 0.1s;
    }
    
    .shimmer-card:nth-child(2)::before {
      animation-delay: 0.2s;
    }
    
    .shimmer-card:nth-child(3)::before {
      animation-delay: 0.3s;
    }
    
    .shimmer-card:nth-child(4)::before {
      animation-delay: 0.4s;
    }

    /* === ANIMATED LOCATION PIN FLOATING BUTTON === */
    .location-fab {
      position: fixed;
      bottom: 90px;
      right: 20px;
      width: 56px;
      height: 56px;
      background: #FFFFFF;
      color: #000000;
      border-radius: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 6px 20px rgba(255, 255, 255, 0.3);
      cursor: pointer;
      z-index: 102;
      transition: all 0.3s ease;
      border: none;
    }

    .location-fab:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 25px rgba(255, 255, 255, 0.4);
    }

    .location-fab:active {
      transform: scale(0.95);
    }

    .location-fab svg {
      width: 28px;
      height: 28px;
      fill: #000000;
      animation: location-pulse 2s infinite;
    }

    .location-fab .badge {
      position: absolute;
      top: -4px;
      right: -4px;
      background: #FF0000;
      color: white;
      font-size: 11px;
      font-weight: bold;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: badge-pulse 1.5s infinite;
      z-index: 1;
    }

    @keyframes location-pulse {
      0%, 100% {
        transform: scale(1);
        fill: #000000;
      }
      50% {
        transform: scale(1.1);
        fill: #FF0000;
      }
    }

    @keyframes badge-pulse {
      0%, 100% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.1);
      }
    }

    /* Broadcast Radar Scanning Overlay */
    .broadcast-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 999;
      display: none;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      backdrop-filter: blur(5px);
      overflow-y: auto;
      padding: 20px;
    }

    .broadcast-overlay.active {
      display: flex;
      animation: fadeIn 0.3s ease;
    }

    .broadcast-container {
      position: relative;
      width: 300px;
      height: 300px;
      margin-bottom: 40px;
      transition: all 0.5s ease;
    }

    .broadcast-container.hidden {
      opacity: 0;
      height: 0;
      margin-bottom: 0;
      overflow: hidden;
    }

    /* Broadcast center with pulsing circles */
    .broadcast-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 30px;
      height: 30px;
      background: #FFFFFF;
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
      z-index: 3;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .broadcast-center svg {
      width: 18px;
      height: 18px;
      fill: #000000;
    }

    /* Pulsing broadcast waves */
    .broadcast-wave {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100px;
      height: 100px;
      border: 2px solid #FFFFFF;
      border-radius: 50%;
      opacity: 0;
      animation: broadcast-wave 2s ease-out infinite;
    }

    .broadcast-wave:nth-child(2) {
      animation-delay: 0.5s;
      width: 200px;
      height: 200px;
      border-width: 1.5px;
    }

    .broadcast-wave:nth-child(3) {
      animation-delay: 1s;
      width: 300px;
      height: 300px;
      border-width: 1px;
    }

    /* Broadcast signal lines */
    .broadcast-signal {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 350px;
      height: 350px;
      transition: opacity 0.3s ease;
    }

    .signal-line {
      position: absolute;
      width: 2px;
      height: 100%;
      background: linear-gradient(to bottom, transparent 0%, #FFFFFF 15%, transparent 30%);
      left: 50%;
      transform-origin: center;
      opacity: 0.3;
    }

    .signal-line:nth-child(1) { transform: rotate(0deg); }
    .signal-line:nth-child(2) { transform: rotate(45deg); }
    .signal-line:nth-child(3) { transform: rotate(90deg); }
    .signal-line:nth-child(4) { transform: rotate(135deg); }

    /* Detected user dots */
    .broadcast-dot {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #FF0000;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 10px #FF0000;
      animation: dot-pulse 1.5s infinite;
      z-index: 2;
    }

    /* Broadcast text */
    .broadcast-text {
      font-size: 20px;
      font-weight: 600;
      margin-bottom: 16px;
      color: #FFFFFF;
      text-align: center;
      font-family: inherit;
      min-height: 28px;
    }

    .broadcast-subtext {
      font-size: 16px;
      color: #8E8E8E;
      text-align: center;
      margin-bottom: 32px;
      font-family: inherit;
      min-height: 20px;
    }

    .broadcast-results {
      width: 100%;
      max-width: 400px;
      display: none;
      flex-direction: column;
      gap: 12px;
      max-height: 60vh;
      overflow-y: auto;
      padding-right: 5px;
    }

    .broadcast-results.active {
      display: flex;
      animation: slideIn 0.5s ease;
    }

    .broadcast-result-item {
      background: #1F1F1F;
      border-radius: 12px;
      padding: 16px;
      display: flex;
      align-items: center;
      animation: slideUp 0.3s ease;
      border: 1px solid #2A2A2A;
      font-family: inherit;
      transition: transform 0.2s ease;
    }

    .broadcast-result-item:hover {
      transform: translateY(-2px);
      border-color: #FFFFFF;
    }

    .broadcast-result-item .profile-photo {
      width: 48px;
      height: 48px;
      margin-right: 12px;
      flex-shrink: 0;
    }

    .broadcast-result-info {
      flex: 1;
      overflow: hidden;
    }

    .broadcast-result-name {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 4px;
      font-family: inherit;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .broadcast-result-distance {
      font-size: 14px;
      color: #8E8E8E;
      font-family: inherit;
    }

    .broadcast-result-actions {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
    }

    .broadcast-result-action {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: #2A2A2A;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: background 0.2s ease;
      font-family: inherit;
    }

    .broadcast-result-action:hover {
      background: #3A3A3A;
    }

    .broadcast-result-action svg {
      width: 18px;
      height: 18px;
      fill: #FFFFFF;
    }

    .broadcast-close {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 40px;
      height: 40px;
      background: #1F1F1F;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border: 1px solid #2A2A2A;
      font-family: inherit;
      transition: background 0.2s ease;
    }

    .broadcast-close:hover {
      background: #2A2A2A;
    }

    .broadcast-close svg {
      width: 24px;
      height: 24px;
      fill: #FFFFFF;
    }

    /* Animations */
    @keyframes broadcast-wave {
      0% {
        transform: translate(-50%, -50%) scale(0.3);
        opacity: 1;
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0;
      }
    }

    @keyframes dot-pulse {
      0%, 100% {
        opacity: 0.3;
        transform: translate(-50%, -50%) scale(0.8);
      }
      50% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1.2);
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Responsive adjustments */
    @media (max-width: 480px) {
      .broadcast-container {
        width: 250px;
        height: 250px;
      }
      
      .broadcast-wave:nth-child(1) {
        width: 83px;
        height: 83px;
      }
      
      .broadcast-wave:nth-child(2) {
        width: 166px;
        height: 166px;
      }
      
      .broadcast-wave:nth-child(3) {
        width: 250px;
        height: 250px;
      }
      
      .broadcast-signal {
        width: 290px;
        height: 290px;
      }
      
      .broadcast-results {
        max-height: 50vh;
      }
    }

    /* Scrollbar styling for results */
    .broadcast-results::-webkit-scrollbar {
      width: 4px;
    }

    .broadcast-results::-webkit-scrollbar-track {
      background: transparent;
    }

    .broadcast-results::-webkit-scrollbar-thumb {
      background: #2A2A2A;
      border-radius: 4px;
    }

    .broadcast-results::-webkit-scrollbar-thumb:hover {
      background: #3A3A3A;
    }
   /* FIX: Prevent CLS - Set dimensions for all images */
img {
  max-width: 100%;
  height: auto;
  aspect-ratio: attr(width) / attr(height);
}

/* FIX: Reserve space for dynamic content */
.profile-photo {
  width: 64px;
  height: 64px;
  flex-shrink: 0;
}

.profile-photo img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* FIX: Request cards have consistent dimensions */
.request-card {
  background: #1F1F1F;
  border-radius: 16px;
  padding: 20px;
  margin-bottom: 20px;
  display: flex;
  flex-direction: column;
  min-height: 240px;
  contain: layout style;
}

/* FIX: Shimmer loader takes up space */
.shimmer-wrapper {
  position: relative;
  width: 100%;
  padding: 16px 24px;
  opacity: 1;
  transition: opacity 0.3s ease;
  z-index: 10;
  contain: layout;
}

.shimmer-wrapper.hidden {
  opacity: 0;
  visibility: hidden;
  pointer-events: none;
}

/* FIX: Broadcast overlay doesn't shift layout */
.broadcast-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.95);
  z-index: 999;
  display: none;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  backdrop-filter: blur(5px);
  overflow-y: auto;
  padding: 20px;
  contain: strict;
}

/* FIX: Prevent font loading shift with system fonts */
body {
  font-display: swap;
}


  </style>
</head>
<body>

  <!-- Kind message shown only on real desktop/laptop (large screen + mouse) -->
  <div class="desktop-message">
    <div class="icon">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
        <path d="M6 2h12a2 2 0 0 1 2 2v16a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm0 4v12h12V6H6zm4 14h4v-2h-4v2z"/>
      </svg>
    </div>
    <h1>Hey there! ðŸ‘‹</h1>
    <p>Thank you for visiting InstaPing on your computer.<br><br>
    For the best and most secure experience, our app is currently available only on phones and tablets.<br><br>
    Please open this page on your mobile device to continue browsing live requests and connecting with others nearby.</p>
  </div>

   <header>
    <div class="logo-small">
      <!-- FIX: Add dimensions and eager loading for LCP -->
      <img 
        src="asset/logo.png" 
        alt="Coded Logo" 
        width="40" 
        height="40"
        loading="eager"
        decoding="sync"
        onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIHZpZXdCb3g9IjAgMCA0MCA0MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIGZpbGw9IiMyQTJBMkEiLz48L3N2Zz4='"
      >
    </div>
    <div class="status-indicator status-available" id="status">
      <svg viewBox="0 0 8 8" width="12" height="12"><circle cx="4" cy="4" r="4"/></svg>
      Available
    </div>
  </header>

  <div class="feed" id="feed">
    <div class="shimmer-wrapper" id="shimmer">
      <!-- Shimmer cards will be generated dynamically -->
    </div>

    <div class="no-requests" id="no-requests">
      <div class="no-requests-icon">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/>
        </svg>
      </div>
      <h3>No live requests right now</h3>
      <p>Be the first to post a request or check back soon â€” people are always looking to connect nearby.</p>
    </div>
  </div>

  <div class="bottom-nav">
    <div class="nav-item active" id="nav-live">
      <div class="nav-icon">
        <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/></svg>
      </div>
      <div>Live</div>
    </div>
    <div class="nav-item" id="nav-favorites">
      <div class="nav-icon">
        <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
      </div>
      <div>Favorites</div>
    </div>
    <div class="nav-item"></div>
    <div class="nav-item" id="nav-chats">
      <div class="nav-icon">
        <svg viewBox="0 0 24 24"><path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"/></svg>
      </div>
      <div>Chats</div>
    </div>
    <div class="nav-item" id="nav-profile">
      <div class="nav-icon">
        <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
      </div>
      <div>Profile</div>
    </div>

    <button class="fab" id="fab-post" aria-label="Post Request">
      <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
    </button>
  </div>

  <!-- Animated Location Floating Button -->
  <button class="location-fab" id="location-fab" aria-label="Broadcast Scan for Nearby Users">
    <svg viewBox="0 0 24 24">
      <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
    </svg>
    <div class="badge" id="location-badge" style="display: none;">3</div>
  </button>

  <!-- Broadcast Scanning Overlay -->
  <div class="broadcast-overlay" id="broadcast-overlay">
    <div class="broadcast-close" id="broadcast-close">
      <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
    </div>
    
    <div class="broadcast-container" id="broadcast-container">
      <div class="broadcast-signal" id="broadcast-signal">
        <div class="signal-line"></div>
        <div class="signal-line"></div>
        <div class="signal-line"></div>
        <div class="signal-line"></div>
      </div>
      
      <div class="broadcast-wave"></div>
      <div class="broadcast-wave"></div>
      <div class="broadcast-wave"></div>
      
      <div class="broadcast-center" id="broadcast-center">
        <svg viewBox="0 0 24 24">
          <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
        </svg>
      </div>
      
      <!-- Broadcast dots will be added dynamically here -->
    </div>
    
    <div class="broadcast-text" id="broadcast-text">Broadcasting signal...</div>
    <div class="broadcast-subtext" id="broadcast-subtext">Searching for users in your area</div>
    
    <div class="broadcast-results" id="broadcast-results">
      <!-- Results will be populated here -->
    </div>
  </div>

  <div id="toast"></div>
<script>
// ==================== POLLING MANAGER (REPLACES WEBSOCKET) ====================
class PollingManager {
    constructor() {
        this.isConnected = false;
        this.pollingInterval = null;
        this.pollingIntervalMs = 10000; // Poll every 10 seconds
        this.lastUpdateTime = 0;
        this.lastFeedCheckTime = 0;
        this.favorites = [];
        this.feedUpdateListeners = [];
        this.statusUpdateListeners = [];
        this.favoriteUpdateListeners = [];
        this.nearbyUserListeners = [];
        this.connectedUsers = new Set();
    }

    connect() {
        console.log('ðŸ“¡ Starting polling mode');
        this.isConnected = true;
        
        // Initial load of favorites
        this.loadFavorites();
        
        // Start polling
        this.startPolling();
        
        // Show connection notification
        showToast('ðŸ“¡ Live updates active (polling mode)');
        
        return true;
    }

    startPolling() {
        if (!this.pollingInterval) {
            console.log(`ðŸ“¡ Starting polling with ${this.pollingIntervalMs}ms interval`);
            this.pollingInterval = setInterval(async () => {
                await this.pollForUpdates();
            }, this.pollingIntervalMs);
        }
    }

    stopPolling() {
        if (this.pollingInterval) {
            clearInterval(this.pollingInterval);
            this.pollingInterval = null;
        }
    }

    async loadFavorites() {
        try {
            const token = localStorage.getItem('token');
            if (!token) return;

            const response = await fetch(`${API_BASE_URL}/favorites`, {
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.ok) {
                this.favorites = await response.json();
                console.log('â­ Favorites loaded:', this.favorites.length);
            }
        } catch (error) {
            console.log('Failed to load favorites:', error.message);
        }
    }

    async pollForUpdates() {
        try {
            await this.checkFeedUpdates();
            await this.checkUserStatuses();
            await this.checkFavoriteUpdates();
        } catch (error) {
            console.log('ðŸ“¡ Polling error:', error.message);
        }
    }

    async checkFeedUpdates() {
        try {
            const token = localStorage.getItem('token');
            if (!token) return;

            const response = await fetch(`${API_BASE_URL}/feed?since=${this.lastFeedCheckTime}&limit=20`, {
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.ok) {
                const newPosts = await response.json();
                
                if (newPosts.length > 0) {
                    console.log('ðŸ”„ Polling found', newPosts.length, 'new/updated posts');
                    
                    // Update last check time
                    this.lastFeedCheckTime = Math.floor(Date.now() / 1000);
                    
                    // Process each post
                    newPosts.forEach(post => {
                        this.processNewPost(post);
                    });
                    
                    // Notify listeners
                    this.feedUpdateListeners.forEach(listener => {
                        try {
                            listener(newPosts);
                        } catch (err) {
                            console.error('Error in feed update listener:', err);
                        }
                    });
                }
            }
        } catch (error) {
            console.log('Feed polling error:', error.message);
        }
    }

    async checkUserStatuses() {
        // Status updates are handled via separate API calls
        return;
    }

    async checkFavoriteUpdates() {
        try {
            const token = localStorage.getItem('token');
            if (!token) return;

            const response = await fetch(`${API_BASE_URL}/favorites`, {
                headers: { 'Authorization': `Bearer ${token}` }
            });

            if (response.ok) {
                const newFavorites = await response.json();
                
                // Check for changes
                const oldIds = new Set(this.favorites.map(f => f.targetUserId));
                const newIds = new Set(newFavorites.map(f => f.targetUserId));
                
                // Find added favorites
                const added = newFavorites.filter(f => !oldIds.has(f.targetUserId));
                // Find removed favorites
                const removed = this.favorites.filter(f => !newIds.has(f.targetUserId));
                
                if (added.length > 0 || removed.length > 0) {
                    console.log('â­ Favorite changes detected:', { added: added.length, removed: removed.length });
                    this.favorites = newFavorites;
                    
                    // Notify listeners
                    this.favoriteUpdateListeners.forEach(listener => {
                        try {
                            listener({ added, removed });
                        } catch (err) {
                            console.error('Error in favorite update listener:', err);
                        }
                    });
                    
                    // Update UI for favorite changes
                    this.updateFavoriteUI(added, removed);
                }
            }
        } catch (error) {
            console.log('Favorite polling error:', error.message);
        }
    }

    processNewPost(post) {
        // Check if post already exists
        const existingCard = document.querySelector(`[data-post-id="${post.id}"]`);
        const currentUserId = parseJwt(localStorage.getItem('token'));
        
        // Skip own posts
        if (post.userId === currentUserId) return;
        
        if (existingCard) {
            // Update existing post
            this.updateExistingPost(post, existingCard);
        } else {
            // Add new post
            this.addNewPost(post);
        }
    }

    updateExistingPost(post, card) {
        // Update content if changed
        if (post.content && post.content !== card.querySelector('.request-text')?.textContent) {
            const textEl = card.querySelector('.request-text');
            if (textEl) {
                textEl.textContent = post.content;
                // Highlight update
                textEl.style.backgroundColor = '#2A2A2A';
                setTimeout(() => {
                    textEl.style.backgroundColor = '';
                }, 1000);
            }
        }
        
        // Update timestamp
        const timeEl = card.querySelector('.time-rating span');
        if (timeEl) {
            timeEl.textContent = 'Updated';
            timeEl.style.color = '#FFFF00';
            setTimeout(() => {
                timeEl.textContent = formatTime(post.updatedAt || post.createdAt);
                timeEl.style.color = '';
            }, 2000);
        }
    }

    addNewPost(post) {
        console.log('âž• Adding new post:', post.id);
        
        // Show notification for new post
        const postUser = post.user || {};
        showToast(`ðŸ“¢ New request from ${postUser.name || 'Someone nearby'}`);
        
        // Add to feed
        addRequestToFeed(post);
        
        // Play subtle sound
        playNotificationSound();
    }

    updateFavoriteUI(added, removed) {
        // Update favorite buttons in the feed
        const cards = document.querySelectorAll('.request-card');
        
        cards.forEach(card => {
            const userId = card.dataset.userId;
            const favoriteBtn = card.querySelector('.favorite');
            
            if (!userId || !favoriteBtn) return;
            
            // Check if this user is now favorited
            const isNowFavorited = added.some(f => f.targetUserId === userId);
            const wasRemoved = removed.some(f => f.targetUserId === userId);
            
            if (isNowFavorited && !favoriteBtn.classList.contains('favorited')) {
                favoriteBtn.classList.add('favorited');
                favoriteBtn.title = 'Remove from favorites';
                favoriteBtn.classList.add('animate');
                setTimeout(() => favoriteBtn.classList.remove('animate'), 600);
            } else if (wasRemoved && favoriteBtn.classList.contains('favorited')) {
                favoriteBtn.classList.remove('favorited');
                favoriteBtn.title = 'Add to favorites';
            }
        });
    }

    send(data) {
        // Simulate sending data (for compatibility with old WebSocket code)
        console.log('ðŸ“¤ Sending via polling manager:', data.type);
        
        // Handle different message types
        switch (data.type) {
            case 'status_update':
                // Update status via API
                this.updateStatus(data.status, data.userId);
                break;
            case 'post_accepted':
            case 'post_favorited':
            case 'post_ignored':
                // These actions already happen via API calls
                // We just log them for debugging
                console.log('Action processed via API:', data.type);
                break;
            case 'subscribe':
                // Handle subscriptions
                console.log('Subscribed to:', data.channel);
                break;
        }
        
        return true;
    }

    async updateStatus(status, userId) {
        try {
            const token = localStorage.getItem('token');
            if (!token) return;

            await fetch(`${API_BASE_URL}/me/status`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ status })
            });
            
            console.log('âœ… Status updated via API:', status);
        } catch (error) {
            console.error('Failed to update status:', error);
        }
    }

    on(event, handler) {
        // Add event listeners for compatibility
        switch (event) {
            case 'connected':
                // Simulate immediate connection
                setTimeout(() => handler(), 100);
                break;
            case 'disconnected':
                // We don't really disconnect in polling mode
                break;
            case 'feed_update':
                this.feedUpdateListeners.push(handler);
                break;
            case 'status_update':
                this.statusUpdateListeners.push(handler);
                break;
            case 'favorite_update':
                this.favoriteUpdateListeners.push(handler);
                break;
            case 'nearby_users':
                this.nearbyUserListeners.push(handler);
                break;
            case 'message':
                // Generic message handler
                break;
        }
        return this;
    }

    off(event, handler) {
        // Remove event listener
        switch (event) {
            case 'feed_update':
                this.feedUpdateListeners = this.feedUpdateListeners.filter(h => h !== handler);
                break;
            case 'status_update':
                this.statusUpdateListeners = this.statusUpdateListeners.filter(h => h !== handler);
                break;
            case 'favorite_update':
                this.favoriteUpdateListeners = this.favoriteUpdateListeners.filter(h => h !== handler);
                break;
            case 'nearby_users':
                this.nearbyUserListeners = this.nearbyUserListeners.filter(h => h !== handler);
                break;
        }
        return this;
    }

    emit(event, data) {
        // Emit events to listeners
        let listeners = [];
        switch (event) {
            case 'connected':
                // Already handled
                break;
            case 'disconnected':
                // Already handled
                break;
            case 'feed_update':
                listeners = this.feedUpdateListeners;
                break;
            case 'status_update':
                listeners = this.statusUpdateListeners;
                break;
            case 'favorite_update':
                listeners = this.favoriteUpdateListeners;
                break;
            case 'nearby_users':
                listeners = this.nearbyUserListeners;
                break;
        }
        
        listeners.forEach(listener => {
            try {
                listener(data);
            } catch (error) {
                console.error(`Error in event handler for ${event}:`, error);
            }
        });
    }

    handleMessage(data) {
        // Handle incoming messages (for compatibility)
        console.log('ðŸ“¨ Message received in polling mode:', data.type);
    }

    disconnect() {
        this.stopPolling();
        this.isConnected = false;
        console.log('ðŸ“¡ Polling stopped');
    }
}

// ==================== GLOBAL VARIABLES ====================
const fallbackImage = 'https://upload.wikimedia.org/wikipedia/commons/8/89/Portrait_Placeholder.png';
const API_BASE_URL = 'https://www.instaping.org/api';
const pollingManager = new PollingManager();

// ==================== HELPER FUNCTIONS ====================

// Create shimmer cards dynamically
function createShimmerCards() {
    const shimmerEl = document.getElementById('shimmer');
    if (!shimmerEl) return;
    
    shimmerEl.innerHTML = '';
    
    for (let i = 0; i < 4; i++) {
        const card = document.createElement('div');
        card.className = 'shimmer-card';
        card.innerHTML = `
            <div class="shimmer-header">
                <div class="shimmer-photo"></div>
                <div class="shimmer-lines">
                    <div class="shimmer-line"></div>
                    <div class="shimmer-line short"></div>
                </div>
            </div>
            <div class="shimmer-category"></div>
            <div class="shimmer-text long"></div>
            <div class="shimmer-text long"></div>
            <div class="shimmer-text medium"></div>
            <div class="shimmer-footer">
                <div class="shimmer-time">
                    <div class="shimmer-time-icon"></div>
                    <div class="shimmer-time-text"></div>
                </div>
                <div class="shimmer-actions">
                    <div class="shimmer-btn"></div>
                    <div class="shimmer-btn"></div>
                    <div class="shimmer-btn"></div>
                </div>
            </div>
        `;
        shimmerEl.appendChild(card);
    }
}

function showToast(message, duration = 2000) {
    const toast = document.getElementById('toast');
    if (!toast) return;
    
    toast.textContent = message;
    toast.classList.add('show');
    clearTimeout(toast.hideTimeout);
    toast.hideTimeout = setTimeout(() => toast.classList.remove('show'), duration);
}

function createConfetti(btn) {
    if (!btn) return;
    
    const colors = ['#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00'];
    const rect = btn.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    for (let i = 0; i < 30; i++) {
        const piece = document.createElement('div');
        piece.classList.add('confetti-piece');
        piece.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        piece.style.left = centerX + (Math.random() - 0.5) * 80 + 'px';
        piece.style.top = centerY + (Math.random() - 0.5) * 80 + 'px';
        piece.style.transform = `rotate(${Math.random() * 360}deg)`;
        piece.style.animationDelay = Math.random() * 0.3 + 's';

        document.body.appendChild(piece);

        setTimeout(() => piece.remove(), 1500);
    }
}

// Play subtle notification sound
function playNotificationSound() {
    try {
        // Create a simple beep using the Web Audio API
        if (window.AudioContext || window.webkitAudioContext) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = 800;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);
        }
    } catch (e) {
        console.log('Audio context not supported or blocked by browser');
    }
}

// Helper function to format distance
function formatDistance(distance) {
    if (distance === undefined || distance === null || distance === '' || distance === 'Unknown') {
        return 'Nearby';
    }
    
    if (typeof distance === 'number') {
        if (distance < 1000) {
            return `${Math.round(distance)}m away`;
        } else {
            return `${(distance / 1000).toFixed(1)}km away`;
        }
    }
    
    if (typeof distance === 'string') {
        if (distance.includes('m away') || distance.includes('km away')) {
            return distance;
        }
        const num = parseFloat(distance);
        if (!isNaN(num)) {
            if (num < 1000) {
                return `${Math.round(num)}m away`;
            } else {
                return `${(num / 1000).toFixed(1)}km away`;
            }
        }
    }
    return 'Nearby';
}

// Enhanced fetch with auth and error handling
async function fetchWithAuth(url, options = {}) {
    const token = localStorage.getItem('token');
    if (!token) {
        showToast('Please log in first');
        setTimeout(() => window.location.href = 'login.html', 1000);
        throw new Error('No token found');
    }

    const headers = {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
        ...options.headers
    };

    try {
        console.log(`ðŸ“¡ Fetching: ${url}`);
        const response = await fetch(url, { ...options, headers });
        
        // Check if response is HTML (error page) instead of JSON
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('text/html')) {
            const text = await response.text();
            console.error('Server returned HTML instead of JSON:', text.substring(0, 200));
            
            if (text.includes('<title>InstaPing</title>')) {
                showToast('API endpoint not found. Please check the URL.');
                throw new Error(`Endpoint not found: ${url}`);
            }
            
            if (response.status === 500) {
                showToast('Server error. Please try again later.');
            }
            throw new Error(`Server error: ${response.status}`);
        }
        
        if (response.status === 401) {
            showToast('Session expired. Please log in again.');
            localStorage.removeItem('token');
            setTimeout(() => window.location.href = 'login.html', 1500);
            throw new Error('Unauthorized');
        }
        
        if (response.status === 404) {
            showToast('Endpoint not found');
            throw new Error('Not found');
        }
        
        if (response.status === 204 || response.headers.get('content-length') === '0') {
            return response;
        }
        
        return response;
    } catch (error) {
        console.error('Fetch error:', error);
        if (error.message !== 'Unauthorized' && error.message !== 'Not found') {
            showToast('Network error. Please check your connection.');
        }
        throw error;
    }
}

// Parse JWT token safely
function parseJwt(token) {
    if (!token) return null;
    
    try {
        const base64Url = token.split('.')[1];
        const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
        const jsonPayload = decodeURIComponent(atob(base64).split('').map(c => 
            '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)
        ).join(''));
        
        const payload = JSON.parse(jsonPayload);
        return payload.userId || payload.sub || payload.id || null;
    } catch (e) {
        console.error('Failed to parse JWT:', e);
        return null;
    }
}

// Check if token is valid
function isValidToken(token) {
    if (!token) return false;
    
    const parts = token.split('.');
    if (parts.length !== 3) return false;
    
    try {
        const payload = parseJwt(token);
        if (!payload) return false;
        
        const expiry = payload.exp;
        if (expiry) {
            if (Date.now() >= expiry * 1000) {
                return false;
            }
        }
        
        return true;
    } catch (e) {
        console.error('Token validation error:', e);
        return false;
    }
}

// ==================== REAL-TIME FEED FUNCTIONS ====================

// Add new request to feed (NO PAGE REFRESH)
function addRequestToFeed(request) {
    const feedEl = document.getElementById('feed');
    const noRequestsEl = document.getElementById('no-requests');
    const shimmerEl = document.getElementById('shimmer');
    
    // Check if elements exist
    if (!feedEl) {
        console.error('Feed element not found');
        return;
    }
    
    // Hide shimmer if visible
    if (shimmerEl && !shimmerEl.classList.contains('hidden')) {
        shimmerEl.classList.add('hidden');
    }
    
    // Hide "no requests" message if showing
    if (noRequestsEl && noRequestsEl.style.display === 'block') {
        noRequestsEl.style.display = 'none';
    }
    
    // Check if request already exists
    const existingCard = feedEl.querySelector(`[data-post-id="${request.id}"]`);
    if (existingCard) return;
    
    const currentUserId = parseJwt(localStorage.getItem('token'));
    if (request.userId === currentUserId) return;
    
    const requestUser = request.user || {};
    
    // Check if this request is already favorited
    let isFavorited = false;
    try {
        // Get current favorites from localStorage or check if this post is in favorites
        const favorites = JSON.parse(localStorage.getItem('favorites') || '[]');
        isFavorited = favorites.some(fav => fav.targetUserId === request.userId);
    } catch (e) {
        console.log('Could not check favorites:', e);
    }
    
    const card = document.createElement('div');
    card.className = 'request-card';
    card.dataset.postId = request.id;
    card.dataset.userId = request.userId;
    card.style.opacity = '0';
    card.style.transform = 'translateY(-20px)';
    
    card.innerHTML = `
        <div class="card-header">
            <div class="profile-photo">
                <img src="${requestUser.avatar || fallbackImage}" alt="${requestUser.name || 'User'}" onerror="this.src='${fallbackImage}'">
            </div>
            <div class="user-info">
                <div class="name-age">${requestUser.name || 'User'}</div>
                <div class="distance">${formatDistance(request.distance)}</div>
                <div class="user-status" style="font-size: 12px; color: #00FF00; margin-top: 4px;">ðŸŸ¢ Live now</div>
            </div>
        </div>
        ${request.category ? `<div class="category">${request.category}</div>` : ''}
        <div class="request-text">${request.content || 'No content'}</div>
        <div class="card-footer">
            <div class="time-rating">
                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/></svg>
                <span>Just now</span>
            </div>
            <div class="actions">
                <button class="action-btn ignore" title="Ignore">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
                </button>
                <button class="action-btn favorite ${isFavorited ? 'favorited' : ''}" title="${isFavorited ? 'Remove from favorites' : 'Add to favorites'}">
                    <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                </button>
                <button class="action-btn accept" title="Accept request">
                    <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
                </button>
            </div>
        </div>
    `;
    
    // Insert at the top of the feed with animation
    if (feedEl.firstChild) {
        feedEl.insertBefore(card, feedEl.firstChild);
    } else {
        feedEl.appendChild(card);
    }
    
    // Animate entry
    setTimeout(() => {
        card.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
        card.style.opacity = '1';
        card.style.transform = 'translateY(0)';
    }, 10);
    
    // Highlight new card
    card.style.boxShadow = '0 0 0 2px #00FF00';
    setTimeout(() => {
        card.style.boxShadow = '';
    }, 1000);
    
    // Check empty state
    setTimeout(checkEmpty, 100);
}

// Update existing request in feed
function updateRequestInFeed(update) {
    if (!update || !update.id) return;
    
    const card = document.querySelector(`[data-post-id="${update.id}"]`);
    if (!card) return;
    
    // Update content if changed
    if (update.content) {
        const textEl = card.querySelector('.request-text');
        if (textEl) {
            textEl.textContent = update.content;
            // Flash effect
            textEl.style.backgroundColor = '#2A2A2A';
            setTimeout(() => {
                textEl.style.backgroundColor = '';
            }, 300);
        }
    }
    
    // Update category if changed
    if (update.category !== undefined) {
        const categoryEl = card.querySelector('.category');
        if (update.category) {
            if (categoryEl) {
                categoryEl.textContent = update.category;
            } else {
                const newCategory = document.createElement('div');
                newCategory.className = 'category';
                newCategory.textContent = update.category;
                const cardHeader = card.querySelector('.card-header');
                if (cardHeader && cardHeader.nextSibling) {
                    cardHeader.parentNode.insertBefore(newCategory, cardHeader.nextSibling);
                }
            }
        } else if (categoryEl) {
            categoryEl.remove();
        }
    }
    
    // Show updated indicator
    const timeEl = card.querySelector('.time-rating span');
    if (timeEl) {
        const originalText = timeEl.textContent;
        timeEl.textContent = 'Updated now';
        timeEl.style.color = '#FFFF00';
        
        setTimeout(() => {
            timeEl.textContent = originalText;
            timeEl.style.color = '';
        }, 2000);
    }
}

// Remove request from feed
function removeRequestFromFeed(requestId) {
    if (!requestId) return;
    
    const card = document.querySelector(`[data-post-id="${requestId}"]`);
    if (card) {
        card.style.transition = 'opacity 0.5s, transform 0.5s';
        card.style.opacity = '0';
        card.style.transform = 'translateX(-100%)';
        
        setTimeout(() => {
            card.remove();
            checkEmpty();
        }, 500);
    }
}

// Update user status in feed
function updateUserStatusInFeed(userId, status) {
    if (!userId || !status) return;
    
    const cards = document.querySelectorAll(`[data-user-id="${userId}"]`);
    cards.forEach(card => {
        const userInfo = card.querySelector('.user-info');
        if (userInfo) {
            let statusEl = userInfo.querySelector('.user-status');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.className = 'user-status';
                statusEl.style.fontSize = '12px';
                statusEl.style.marginTop = '4px';
                userInfo.appendChild(statusEl);
            }
            
            let statusText = '';
            let statusColor = '';
            let statusEmoji = '';
            
            switch(status) {
                case 'available':
                    statusText = 'Available';
                    statusColor = '#00FF00';
                    statusEmoji = 'ðŸŸ¢';
                    break;
                case 'busy':
                    statusText = 'Busy';
                    statusColor = '#FFFF00';
                    statusEmoji = 'ðŸŸ¡';
                    break;
                case 'offline':
                    statusText = 'Offline';
                    statusColor = '#FF0000';
                    statusEmoji = 'ðŸ”´';
                    break;
            }
            
            statusEl.textContent = `${statusEmoji} ${statusText}`;
            statusEl.style.color = statusColor;
        }
    });
}

// Update user status in broadcast results
function updateUserStatusInBroadcast(userId, status) {
    if (!userId || !status) return;
    
    const broadcastResults = document.getElementById('broadcast-results');
    if (!broadcastResults) return;
    
    const resultItems = broadcastResults.querySelectorAll('.broadcast-result-item');
    resultItems.forEach(item => {
        const actionBtn = item.querySelector('.broadcast-result-action');
        if (actionBtn && actionBtn.dataset.userId === userId) {
            const statusIndicator = item.querySelector('.user-status-indicator');
            if (!statusIndicator) {
                const newStatus = document.createElement('div');
                newStatus.className = 'user-status-indicator';
                newStatus.style.width = '8px';
                newStatus.style.height = '8px';
                newStatus.style.borderRadius = '50%';
                newStatus.style.marginLeft = '8px';
                item.querySelector('.broadcast-result-info').appendChild(newStatus);
            }
            
            const indicator = item.querySelector('.user-status-indicator');
            switch(status) {
                case 'available':
                    indicator.style.backgroundColor = '#00FF00';
                    break;
                case 'busy':
                    indicator.style.backgroundColor = '#FFFF00';
                    break;
                case 'offline':
                    indicator.style.backgroundColor = '#FF0000';
                    break;
            }
        }
    });
}

function formatTime(timestamp) {
    if (!timestamp) return 'Just now';
    const diff = Date.now() - (timestamp * 1000 || Date.now());
    if (diff < 60000) return 'Just now';
    if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
    if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
    return Math.floor(diff / 86400000) + 'd ago';
}

function checkEmpty() {
    const feedEl = document.getElementById('feed');
    const noRequestsEl = document.getElementById('no-requests');
    const shimmerEl = document.getElementById('shimmer');
    
    // Check if elements exist
    if (!feedEl) {
        console.warn('Feed element not found in checkEmpty');
        return;
    }
    
    const cards = feedEl.querySelectorAll('.request-card');
    
    if (cards.length === 0) {
        // Hide shimmer if visible
        if (shimmerEl && !shimmerEl.classList.contains('hidden')) {
            shimmerEl.classList.add('hidden');
        }
        // Show "no requests" message
        if (noRequestsEl) {
            noRequestsEl.style.display = 'block';
        }
    } else {
        // Hide "no requests" message
        if (noRequestsEl) {
            noRequestsEl.style.display = 'none';
        }
        // Hide shimmer if visible
        if (shimmerEl && !shimmerEl.classList.contains('hidden')) {
            shimmerEl.classList.add('hidden');
        }
    }
}

// ==================== BROADCAST SCAN FUNCTIONS ====================

let isScanning = false;
let nearbyUsers = [];
let broadcastDots = [];

// Function to add broadcast dots
function addBroadcastDots(users) {
    const broadcastContainer = document.getElementById('broadcast-container');
    if (!broadcastContainer) return;
    
    // Clear existing dots
    broadcastDots.forEach(dot => dot && dot.remove());
    broadcastDots = [];
    
    users.forEach((user, index) => {
        const angle = (index / users.length) * Math.PI * 2;
        const distance = 0.7;
        
        const containerSize = broadcastContainer.offsetWidth;
        const center = containerSize / 2;
        const x = center + Math.cos(angle) * (distance * center * 0.4);
        const y = center + Math.sin(angle) * (distance * center * 0.4);
        
        const dot = document.createElement('div');
        dot.className = 'broadcast-dot';
        dot.style.left = `${x}px`;
        dot.style.top = `${y}px`;
        dot.dataset.userId = user.id;
        dot.dataset.index = index;
        dot.style.animationDelay = `${index * 0.2}s`;
        
        broadcastContainer.appendChild(dot);
        broadcastDots.push(dot);
    });
}

async function broadcastScan() {
    if (isScanning) return;
    
    isScanning = true;
    const broadcastOverlay = document.getElementById('broadcast-overlay');
    const broadcastText = document.getElementById('broadcast-text');
    const broadcastSubtext = document.getElementById('broadcast-subtext');
    const broadcastContainer = document.getElementById('broadcast-container');
    const broadcastResults = document.getElementById('broadcast-results');
    
    if (!broadcastOverlay || !broadcastText || !broadcastSubtext || !broadcastContainer || !broadcastResults) {
        console.error('Broadcast elements not found');
        isScanning = false;
        return;
    }
    
    broadcastOverlay.classList.add('active');
    broadcastText.textContent = 'Broadcasting signal...';
    broadcastSubtext.textContent = 'Searching for users in your area';
    
    // Reset results
    broadcastResults.innerHTML = '';
    broadcastResults.classList.remove('active');
    broadcastContainer.classList.remove('hidden');
    
    try {
        for (let i = 0; i < 3; i++) {
            await new Promise(resolve => setTimeout(resolve, 700));
            
            const res = await fetchWithAuth(`${API_BASE_URL}/users/nearby`);
            
            if (res.ok) {
                let users = [];
                try {
                    users = await res.json();
                } catch (jsonError) {
                    console.error('Failed to parse JSON:', jsonError);
                    users = [];
                }
                
                nearbyUsers = Array.isArray(users) ? users.slice(0, 6) : [];
                
                if (nearbyUsers.length > 0) {
                    addBroadcastDots(nearbyUsers);
                    
                    if (i === 0) {
                        broadcastText.textContent = 'Signal detected...';
                        broadcastSubtext.textContent = 'Analyzing nearby signals';
                    } else if (i === 1) {
                        broadcastText.textContent = 'Locating users...';
                        broadcastSubtext.textContent = 'Pinpointing exact locations';
                    } else if (i === 2) {
                        broadcastText.textContent = `${nearbyUsers.length} user${nearbyUsers.length > 1 ? 's' : ''} found nearby`;
                        broadcastSubtext.textContent = 'Scroll to browse';
                        
                        setTimeout(() => {
                            displayBroadcastResults(nearbyUsers);
                            broadcastResults.classList.add('active');
                        }, 500);
                        
                        const locationBadge = document.getElementById('location-badge');
                        if (locationBadge) {
                            locationBadge.textContent = nearbyUsers.length;
                            locationBadge.style.display = 'flex';
                        }
                    }
                } else if (i === 2) {
                    broadcastText.textContent = 'No signals detected';
                    broadcastSubtext.textContent = 'No users found in your immediate area';
                    displayNoUsersFound();
                    broadcastResults.classList.add('active');
                }
            }
        }
    } catch (err) {
        console.error('Broadcast scan error:', err);
        if (err.message !== 'Unauthorized') {
            broadcastText.textContent = 'Broadcast failed';
            broadcastSubtext.textContent = 'Signal transmission interrupted';
            displayErrorState();
            broadcastResults.classList.add('active');
            showToast('Failed to scan nearby users');
        }
    } finally {
        isScanning = false;
    }
}

function displayBroadcastResults(users) {
    const broadcastResults = document.getElementById('broadcast-results');
    if (!broadcastResults) return;
    
    broadcastResults.innerHTML = '';
    
    users.forEach((user, index) => {
        setTimeout(() => {
            const resultItem = document.createElement('div');
            resultItem.className = 'broadcast-result-item';
            resultItem.style.animation = 'slideUp 0.3s ease';
            resultItem.style.animationDelay = `${index * 0.1}s`;
            
            resultItem.innerHTML = `
                <div class="profile-photo">
                    <img src="${user.avatar || fallbackImage}" alt="${user.name || 'User'}" onerror="this.src='${fallbackImage}'">
                </div>
                <div class="broadcast-result-info">
                    <div class="broadcast-result-name">${user.name || 'User'}</div>
                    <div class="broadcast-result-distance">${formatDistance(user.distance)}</div>
                </div>
                <div class="broadcast-result-actions">
                    <button class="broadcast-result-action" data-user-id="${user.id}" data-action="chat" title="Start Chat">
                        <svg viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H5.17l-.59.59-.58.58V4h16v12z"/></svg>
                    </button>
                    <button class="broadcast-result-action" data-user-id="${user.id}" data-action="view" title="View Profile">
                        <svg viewBox="0 0 24 24"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5z"/></svg>
                    </button>
                </div>
            `;
            
            broadcastResults.appendChild(resultItem);
        }, index * 100);
    });
}

function displayNoUsersFound() {
    const broadcastResults = document.getElementById('broadcast-results');
    if (!broadcastResults) return;
    
    broadcastResults.innerHTML = `
        <div class="broadcast-result-item" style="flex-direction: column; text-align: center; padding: 32px 16px;">
            <div style="width: 64px; height: 64px; background: #2A2A2A; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 16px;">
                <svg viewBox="0 0 24 24" width="32" height="32" fill="#8E8E8E">
                    <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
                </svg>
            </div>
            <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">No users nearby</div>
            <div style="font-size: 14px; color: #8E8E8E;">Try moving to a different location or check back later</div>
        </div>
    `;
}

function displayErrorState() {
    const broadcastResults = document.getElementById('broadcast-results');
    if (!broadcastResults) return;
    
    broadcastResults.innerHTML = `
        <div class="broadcast-result-item" style="flex-direction: column; text-align: center; padding: 32px 16px;">
            <div style="width: 64px; height: 64px; background: #2A2A2A; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto 16px;">
                <svg viewBox="0 0 24 24" width="32" height="32" fill="#FF0000">
                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/>
                </svg>
            </div>
            <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">Scan failed</div>
            <div style="font-size: 14px; color: #8E8E8E;">Please check your connection and try again</div>
            <button style="margin-top: 16px; padding: 10px 20px; background: #FFFFFF; color: #000000; border: none; border-radius: 20px; font-weight: 600; cursor: pointer; font-family: inherit;" onclick="broadcastScan()">
                Retry Scan
            </button>
        </div>
    `;
}

// ==================== APPLICATION INITIALIZATION ====================

(function() {
    // Create shimmer cards on load (takes up space immediately)
    createShimmerCards();
    
    // Check token first
    const token = localStorage.getItem('token');
    if (!token) {
        showToast('Please log in to continue');
        setTimeout(() => window.location.href = 'login.html', 1000);
        return;
    }
    
    if (!isValidToken(token)) {
        showToast('Session expired. Please log in again.');
        localStorage.removeItem('token');
        setTimeout(() => window.location.href = 'login.html', 1500);
        return;
    }

    const currentUserId = parseJwt(token);
    if (!currentUserId) {
        showToast('Invalid session. Please log in again.');
        localStorage.removeItem('token');
        setTimeout(() => window.location.href = 'login.html', 1500);
        return;
    }

    console.log('Current user ID:', currentUserId);

    // ==================== STATUS INDICATOR ====================
    
    const statusEl = document.getElementById('status');
    const statuses = [
        { text: 'Available', class: 'status-available', value: 'available' },
        { text: 'Busy', class: 'status-busy', value: 'busy' },
        { text: 'Offline', class: 'status-offline', value: 'offline' }
    ];
    let currentStatusIndex = 0;

    // Load status immediately (critical for user experience)
    loadStatus();

    async function loadStatus() {
        try {
            // Use requestIdleCallback to load status when browser is idle
            if ('requestIdleCallback' in window) {
                requestIdleCallback(async () => {
                    await performStatusLoad();
                }, { timeout: 1000 });
            } else {
                // Fallback for older browsers
                setTimeout(performStatusLoad, 100);
            }
        } catch (err) {
            console.error('Load status error:', err);
            // Set default status immediately to prevent UI shift
            updateStatusUI();
        }
    }

    async function performStatusLoad() {
        try {
            const res = await fetchWithAuth(`${API_BASE_URL}/me`);
            
            if (!res.ok) {
                const errorText = await res.text();
                throw new Error(`Failed to load profile: ${res.status} ${errorText}`);
            }
            
            let data;
            try {
                data = await res.json();
            } catch (jsonError) {
                console.error('Failed to parse profile JSON:', jsonError);
                throw new Error('Invalid server response');
            }
            
            const statusValue = data.status || 'available';
            const index = statuses.findIndex(s => s.value === statusValue);
            if (index !== -1) {
                currentStatusIndex = index;
                updateStatusUI();
            }
        } catch (err) {
            console.error('Load status error:', err);
            if (err.message !== 'Unauthorized') {
                showToast('Failed to load status');
            }
            // Ensure UI is updated even on error
            updateStatusUI();
        }
    }

    function updateStatusUI() {
        if (!statusEl) return;
        
        const s = statuses[currentStatusIndex];
        statusEl.className = `status-indicator ${s.class}`;
        statusEl.innerHTML = `<svg viewBox="0 0 8 8" width="12" height="12"><circle cx="4" cy="4" r="4"/></svg> ${s.text}`;
        
        // Prevent layout shift by ensuring element has consistent dimensions
        statusEl.style.minWidth = '120px';
        statusEl.style.minHeight = '36px';
    }

    if (statusEl) {
        statusEl.addEventListener('click', async () => {
            currentStatusIndex = (currentStatusIndex + 1) % statuses.length;
            updateStatusUI();
            const newStatus = statuses[currentStatusIndex].value;
            try {
                const res = await fetchWithAuth(`${API_BASE_URL}/me/status`, {
                    method: 'PUT',
                    body: JSON.stringify({ status: newStatus })
                });
                
                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(`Failed to update status: ${errorText}`);
                }
                
                showToast(`Status changed to ${newStatus}`);
                
                // Send status update via polling manager
                pollingManager.send({
                    type: 'status_update',
                    status: newStatus,
                    userId: currentUserId
                });
            } catch (err) {
                console.error('Update status error:', err);
                if (err.message !== 'Unauthorized') {
                    showToast('Failed to update status');
                }
            }
        });
    }

    // ==================== INITIAL FEED LOAD ====================
    
    async function loadFeed() {
        const feedEl = document.getElementById('feed');
        const noRequestsEl = document.getElementById('no-requests');
        const shimmerEl = document.getElementById('shimmer');
        
        // Check if elements exist
        if (!feedEl || !noRequestsEl || !shimmerEl) {
            console.error('Required elements not found for loadFeed');
            return;
        }
        
        // Show shimmer
        shimmerEl.classList.remove('hidden');
        feedEl.innerHTML = '';
        feedEl.appendChild(shimmerEl);

        try {
            const res = await fetchWithAuth(`${API_BASE_URL}/feed`);
            
            if (!res.ok) {
                const errorText = await res.text();
                throw new Error(`Failed to load feed: ${res.status} ${errorText}`);
            }
            
            let posts;
            try {
                posts = await res.json();
            } catch (jsonError) {
                console.error('Failed to parse feed JSON:', jsonError);
                posts = [];
            }

            feedEl.innerHTML = '';
            const postsArray = Array.isArray(posts) ? posts : [];

            if (postsArray.length === 0) {
                noRequestsEl.style.display = 'block';
                shimmerEl.classList.add('hidden');
                return;
            }

            noRequestsEl.style.display = 'none';

            let favorites = [];
            try {
                const favRes = await fetchWithAuth(`${API_BASE_URL}/favorites`);
                if (favRes.ok) {
                    const favData = await favRes.json();
                    favorites = Array.isArray(favData) ? favData : [];
                }
            } catch (err) {
                console.error('Failed to load favorites:', err);
                favorites = [];
            }

            const favoriteUserIds = new Set(favorites.map(f => f.targetUserId || ''));

        
postsArray.forEach(post => {
    const postUser = post.user || {};
    const cardUserId = postUser.id || post.userId;

    if (cardUserId === currentUserId) return;

    // Check if already favorited
    let isFavorited = favoriteUserIds.has(cardUserId);

    const card = document.createElement('div');
    card.className = 'request-card';
    card.dataset.postId = post.id;
    card.dataset.userId = cardUserId;

    card.innerHTML = `
        <div class="card-header">
            <div class="profile-photo">
                <img src="${postUser.avatar || fallbackImage}" alt="${postUser.name || 'User'}" onerror="this.src='${fallbackImage}'">
            </div>
            <div class="user-info">
                <div class="name-age">${postUser.name || 'User'}</div>
                <div class="distance">${formatDistance(post.distance)}</div>
                <div class="user-status" style="font-size: 12px; color: #00FF00; margin-top: 4px;">ðŸŸ¢ Live now</div>
            </div>
        </div>
        ${post.category ? `<div class="category">${post.category}</div>` : ''}
        <div class="request-text">${post.content || 'No content'}</div>
        <div class="card-footer">
            <div class="time-rating">
                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/></svg>
                <span>${formatTime(post.createdAt)}</span>
            </div>
            <div class="actions">
                <button class="action-btn ignore" title="Ignore">
                    <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
                </button>
                <button class="action-btn favorite ${isFavorited ? 'favorited' : ''}" title="${isFavorited ? 'Remove from favorites' : 'Add to favorites'}">
                    <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
                </button>
                <button class="action-btn accept" title="Accept request">
                    <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
                </button>
            </div>
        </div>
    `;
    feedEl.appendChild(card);
});
            shimmerEl.classList.add('hidden');
            checkEmpty();
        } catch (err) {
            console.error('Feed load error:', err);
            if (err.message !== 'Unauthorized') {
                showToast('Failed to load live requests');
                feedEl.innerHTML = '<div class="loading-state">Error loading. <button onclick="location.reload()">Retry</button></div>';
            }
            shimmerEl.classList.add('hidden');
        }
    }

    // ==================== EVENT HANDLERS ====================
    
    document.addEventListener('click', async (e) => {
        const btn = e.target.closest('.action-btn');
        if (!btn) return;

        const card = btn.closest('.request-card');
        if (!card) return;
        
        const userId = card.dataset.userId;
        const postId = card.dataset.postId;

        if (userId === currentUserId) {
            showToast('Cannot interact with your own post');
            return;
        }

        if (btn.classList.contains('accept')) {
            try {
                const res = await fetchWithAuth(`${API_BASE_URL}/chats`, {
                    method: 'POST',
                    body: JSON.stringify({ participants: [userId] })
                });
                
                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(`Failed to create chat: ${errorText}`);
                }
                
                let data;
                try {
                    data = await res.json();
                } catch (jsonError) {
                    throw new Error('Invalid server response');
                }
                
                showToast('ðŸ¤ Chat created!');
                
                // Notify via polling manager
                pollingManager.send({
                    type: 'post_accepted',
                    postId: postId,
                    userId: currentUserId,
                    targetUserId: userId,
                    chatId: data.id
                });
                
                // Remove card with animation
                card.style.transition = 'opacity 0.5s, transform 0.5s';
                card.style.opacity = '0';
                card.style.transform = 'translateX(100%)';
                
                setTimeout(() => {
                    card.remove();
                    checkEmpty();
                    
                    // Navigate to chat after animation
                    setTimeout(() => {
                        window.location.href = `chat.html?id=${data.id}`;
                    }, 300);
                }, 500);
                
            } catch (err) {
                console.error('Chat creation error:', err);
                if (err.message !== 'Unauthorized') {
                    showToast('Failed to create chat: ' + err.message);
                }
            }
     } else if (btn.classList.contains('favorite')) {
    btn.classList.add('animate');
    setTimeout(() => btn.classList.remove('animate'), 600);

    const isCurrentlyFavorited = btn.classList.contains('favorited');

    try {
        if (isCurrentlyFavorited) {
            // REMOVE from favorites - send as JSON body
            const res = await fetchWithAuth(`${API_BASE_URL}/favorite`, {
                method: 'DELETE',
                body: JSON.stringify({ targetUserId: userId }),
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (res.status === 404) {
                // Already removed, just update UI
                showToast('Already removed from favorites');
            } else if (!res.ok) {
                const errorText = await res.text();
                throw new Error(`Failed to remove favorite: ${errorText}`);
            } else {
                showToast('ðŸ’” Removed from favorites');
            }
            
            btn.classList.remove('favorited');
            btn.title = 'Add to favorites';
            
        } else {
            // ADD to favorites
            const res = await fetchWithAuth(`${API_BASE_URL}/favorite`, {
                method: 'POST',
                body: JSON.stringify({ targetUserId: userId })
            });

            if (res.status === 409) {
                showToast('Already in favorites');
                btn.classList.add('favorited');
                btn.title = 'Remove from favorites';
            } else if (!res.ok) {
                const errorText = await res.text();
                throw new Error(`Failed to add favorite: ${errorText}`);
            } else {
                showToast('â¤ï¸ Added to favorites');
                btn.classList.add('favorited');
                createConfetti(btn);
                btn.title = 'Remove from favorites';
            }
        }

        // Notify via polling manager
        pollingManager.send({
            type: 'post_favorited',
            postId: postId,
            userId: currentUserId,
            targetUserId: userId,
            action: isCurrentlyFavorited ? 'removed' : 'added'
        });

        // Remove card with animation
        card.style.transition = 'opacity 0.5s, transform 0.5s';
        card.style.opacity = '0';
        card.style.transform = 'translateY(-20px)';
        
        setTimeout(() => {
            card.remove();
            checkEmpty();
        }, 500);

    } catch (err) {
        console.error('Favorite action error:', err);
        if (err.message !== 'Unauthorized') {
            showToast('Failed to update favorite: ' + err.message);
        }
        // Revert UI if error
        btn.classList.toggle('favorited');
        btn.classList.toggle('animate');
    }

        } else if (btn.classList.contains('ignore')) {
            // Animate ignore
            btn.style.transform = 'rotate(90deg)';
            setTimeout(() => {
                btn.style.transform = '';
            }, 300);
            
            // Remove card with animation
            card.style.transition = 'opacity 0.5s, transform 0.5s';
            card.style.opacity = '0';
            card.style.transform = 'translateX(-100%)';
            
            setTimeout(() => {
                card.remove();
                checkEmpty();
            }, 500);
            
            // Notify via polling manager
            pollingManager.send({
                type: 'post_ignored',
                postId: postId,
                userId: currentUserId,
                targetUserId: userId
            });
            
            showToast('ðŸ‘Ž Request ignored');
        }
    });

    document.addEventListener('click', (e) => {
        const cardHeader = e.target.closest('.card-header');
        if (cardHeader) {
            const card = cardHeader.closest('.request-card');
            if (!card) return;
            
            const userId = card.dataset.userId;
            if (userId && userId !== currentUserId) {
                window.location.href = `view-profile.html?id=${userId}`;
            }
        }
    });

    // ==================== BROADCAST EVENT LISTENERS ====================
    
    const locationFab = document.getElementById('location-fab');
    const broadcastClose = document.getElementById('broadcast-close');
    const broadcastOverlay = document.getElementById('broadcast-overlay');

    if (locationFab) {
        locationFab.addEventListener('click', broadcastScan);
    }
    
    if (broadcastClose) {
        broadcastClose.addEventListener('click', () => {
            if (broadcastOverlay) {
                broadcastOverlay.classList.remove('active');
            }
        });
    }
    
    if (broadcastOverlay) {
        broadcastOverlay.addEventListener('click', (e) => {
            if (e.target === broadcastOverlay) {
                broadcastOverlay.classList.remove('active');
            }
        });
    }

    // Handle broadcast result actions
    document.addEventListener('click', async (e) => {
        const actionBtn = e.target.closest('.broadcast-result-action');
        if (!actionBtn) return;
        
        const userId = actionBtn.dataset.userId;
        const action = actionBtn.dataset.action;
        
        if (!userId) return;
        
        if (action === 'chat') {
            try {
                const res = await fetchWithAuth(`${API_BASE_URL}/chats`, {
                    method: 'POST',
                    body: JSON.stringify({ participants: [userId] })
                });
                
                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(`Failed to create chat: ${errorText}`);
                }
                
                let data;
                try {
                    data = await res.json();
                } catch (jsonError) {
                    throw new Error('Invalid server response');
                }
                
                showToast('Chat created!');
                const broadcastOverlay = document.getElementById('broadcast-overlay');
                if (broadcastOverlay) {
                    broadcastOverlay.classList.remove('active');
                }
                setTimeout(() => window.location.href = `chat.html?id=${data.id}`, 800);
            } catch (err) {
                console.error('Chat creation error:', err);
                if (err.message !== 'Unauthorized') {
                    showToast('Failed to create chat: ' + err.message);
                }
            }
        } else if (action === 'view') {
            const broadcastOverlay = document.getElementById('broadcast-overlay');
            if (broadcastOverlay) {
                broadcastOverlay.classList.remove('active');
            }
            window.location.href = `view-profile.html?id=${userId}`;
        }
    });

    // ==================== NAVIGATION ====================
    
    const navLive = document.getElementById('nav-live');
    const navFavorites = document.getElementById('nav-favorites');
    const navChats = document.getElementById('nav-chats');
    const navProfile = document.getElementById('nav-profile');
    const fabPost = document.getElementById('fab-post');
    
    if (navLive) {
        navLive.addEventListener('click', () => {
            // Just reload the feed, not the whole page
            loadFeed();
            showToast('ðŸ”„ Feed refreshed');
        });
    }
    
    if (navFavorites) {
        navFavorites.addEventListener('click', () => window.location.href = 'favorites.html');
    }
    
    if (navChats) {
        navChats.addEventListener('click', () => window.location.href = 'chats.html');
    }
    
    if (navProfile) {
        navProfile.addEventListener('click', () => window.location.href = 'my-profile.html');
    }

    if (fabPost) {
        fabPost.addEventListener('click', () => {
            window.location.href = 'post.html';
        });
    }

    // ==================== POLLING INITIALIZATION ====================
    
    // Start polling after initial load
    setTimeout(() => {
        pollingManager.connect();
        
        // Simulate connection event
        pollingManager.on('connected', () => {
            console.log('âœ… Polling mode active');
            
            // Update status indicator
            const statusIndicator = document.querySelector('.status-indicator');
            if (statusIndicator) {
                statusIndicator.style.boxShadow = '0 0 10px #00FF00';
                setTimeout(() => {
                    statusIndicator.style.boxShadow = '';
                }, 2000);
            }
        });
        
    }, 1000);

    // Clean up polling on page unload
    window.addEventListener('beforeunload', () => {
        pollingManager.disconnect();
    });

    // ==================== SERVICE WORKER ====================
    
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js')
                .then(reg => console.log('Service Worker registered', reg))
                .catch(err => console.error('Service Worker registration failed', err));
        });
    }

    // ==================== INITIALIZE APP ====================
    
    // Initialize
    loadStatus();
    loadFeed();

    // Auto-refresh feed every 2 minutes as backup
    setInterval(() => {
        console.log('ðŸ”„ Auto-refreshing feed');
        loadFeed();
    }, 120000); // 2 minutes
})();
</script>
</body>

</html>




